<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue基础语法</title>
    <link href="/posts/e0886ac8/index.html"/>
    <url>/posts/e0886ac8/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="第一个Vue实例"><a href="#第一个Vue实例" class="headerlink" title="第一个Vue实例"></a>第一个Vue实例</h2><p><strong>安装和使用</strong></p><ol><li><p>直接使用<code>&lt;script&gt;</code>引入</p><p>在Vue官网中下载开发版本的Vue.js，在项目使用<code>&lt;script&gt;</code>标签进行引入</p></li></ol><p><img src="https://files.alexhchu.com/2020/11/02/69da2c4bc6e4a.png" alt="image-20201102151314989"></p><ol start="2"><li>使用<code>CDN</code></li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><strong>编写实例</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        msg: <span class="hljs-string">&quot;Hello Vue&quot;</span>    &#125;&#125;)</code></pre><ul><li>el：挂载点 挂载要操作的DOM元素</li><li>data：页面中要渲染的数据</li></ul><h2 id="挂载点，模板与实例"><a href="#挂载点，模板与实例" class="headerlink" title="挂载点，模板与实例"></a>挂载点，模板与实例</h2><p><strong>挂载点</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        msg: <span class="hljs-string">&quot;Hello Vue&quot;</span>    &#125;&#125;)</code></pre><p><code>div</code>元素就是<code>Vue</code>实例的挂载点，因为<code>Vue</code>实例的<code>el</code>的值和<code>div</code>的<code>id</code>属性相对应，<code>Vue</code>只会处理挂载点下的内容</p><p><strong>模板</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        msg: <span class="hljs-string">&quot;Hello Vue&quot;</span>    &#125;&#125;)</code></pre><p>在挂载点内部的内容都称为模板</p><p>模板还可以写在<code>Vue</code>实例中</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    template:<span class="hljs-string">&quot;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&quot;</span>,    data: &#123;        msg: <span class="hljs-string">&quot;Hello Vue&quot;</span>    &#125;&#125;)</code></pre><p><strong>实例</strong></p><p>在<code>Vue</code>实例中，只需要指定一个挂载点，和要渲染的数据，<code>Vue</code>会自动的结合模板和数据，生成最终要展示的内容，然后把内容放在挂载点中`</p><h2 id="Vue中的数据，事件和方法"><a href="#Vue中的数据，事件和方法" class="headerlink" title="Vue中的数据，事件和方法"></a>Vue中的数据，事件和方法</h2><p><strong>数据</strong></p><p>在<code>Vue</code>实例的数据项中，可以配置任意的数据名字在模板中使用 </p><p><code>&#123;&#123;&#125;&#125;</code>这种语法叫做插值表达式</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        num:<span class="hljs-number">123</span>    &#125;&#125;)</code></pre><p>除了使用插值表达式，还可以使用<code>v-text</code>  <code>v-text</code>是<code>Vue</code>中的一个指令，指令中是一个变量，<code>&lt;h1&gt;</code>中会显示这个变得值</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://files.alexhchu.com/2020/11/02/fb47b95ce154a.png" alt="image-20201102154548723"></p><p>使用<code>v-html</code>这个指令也可以达到这个效果</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-html</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://files.alexhchu.com/2020/11/02/fb47b95ce154a.png" alt="image-20201102154548723"></p><p><code>v-text</code>和<code>v-html</code>的区别：</p><ul><li><code>v-tetx</code>会把<code>html</code>语句转义</li><li><code>v-html</code>不会把<code>html</code>语句转义</li></ul><p><strong>事件/方法</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-on:click</span> = <span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        msg: <span class="hljs-string">&quot;Hello Vue&quot;</span>,        num:<span class="hljs-number">123</span>    &#125;,    methods:&#123;        handleClick: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(<span class="hljs-number">123</span>)        &#125;    &#125;&#125;)</code></pre><ul><li><code>v-on:</code>：往html元素上绑定事件 后面跟一个函数，当点击<code>p</code>标签时，会执行<code>handleClick</code>函数中的<code>alert</code>的方法 ，也可以简写成 <code>@ </code>符号</li><li><code>methods</code>：所有执行的方法都放在<code>Vue</code>实例的<code>methods</code>方法里面</li></ul><h2 id="属性绑定和双向数据绑定"><a href="#属性绑定和双向数据绑定" class="headerlink" title="属性绑定和双向数据绑定"></a>属性绑定和双向数据绑定</h2><p><strong>属性绑定</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;this is div&quot;</span>&gt;</span>Hello Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        title: <span class="hljs-string">&quot;this is div&quot;</span>    &#125;&#125;)</code></pre><p><code>v-bind</code>：</p><ul><li>属性绑定指令</li><li>将<code>Vue</code>实例中的<code>title</code>与<code>div</code>元素中的<code>title</code>属性进行绑定，div元素的<code>title</code>值就是<code>Vue</code>实例中<code>title</code>的值</li></ul><blockquote><p>v-bind: 可以简写成:  v-bind:title  =  :title</p><p>v-bind:title= 当使用模板指令是，= 后面的内容不再是字符串，而是JS表达式</p></blockquote><p><strong>双向数据绑定</strong></p><p>双向绑定和单向绑定的区别</p><ul><li>单向绑定：数据可以决定页面的内容，但是页面不能决定数据的内容</li><li>双向绑定：数据可以操作页面，页面可以操作数据</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;content&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        title: <span class="hljs-string">&quot;this is div&quot;</span>,        content: <span class="hljs-string">&quot;this is content&quot;</span>    &#125;&#125;)</code></pre><p><code>v-model</code>：双向绑定语法，它会根据控件类型自动选取正确的方法来更新元素</p><h2 id="Vue中计算属性和侦听器"><a href="#Vue中计算属性和侦听器" class="headerlink" title="Vue中计算属性和侦听器"></a>Vue中计算属性和侦听器</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    姓: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span>    名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        firstName: <span class="hljs-string">&quot;&quot;</span>,        lastName: <span class="hljs-string">&quot;&quot;</span>,    &#125;,    computed: &#123;        fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;    &#125;</code></pre><p><code>computed</code>：计算属性，将<code>firstName</code>和<code>lastName</code>的数据组合成<code>fullName</code>进行返回，如果<code>firstName</code>和<code>lastName</code>数据没有改变，<code>fullName</code>不会重新计算，而是使用上一次计算的缓存值</p><p><img src="https://files.alexhchu.com/2020/11/02/39648124f9d10.gif" alt="GIF 2020-11-2 16-45-25"></p><p><strong>侦听器</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    姓: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span>    名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        firstName: <span class="hljs-string">&quot;&quot;</span>,        lastName: <span class="hljs-string">&quot;&quot;</span>,        count: <span class="hljs-number">0</span>    &#125;,    computed: &#123;        fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;    &#125;,    watch: &#123;        fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">this</span>.count++        &#125;    &#125;&#125;)</code></pre><p><code>watch</code>：监听数据的变化，·fullName·数据发生变化，·count·属性就会进行改变</p><h2 id="v-if-v-show-v-for指令"><a href="#v-if-v-show-v-for指令" class="headerlink" title="v-if v-show v-for指令"></a>v-if v-show v-for指令</h2><p><strong>v-if</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>Hello Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        show: <span class="hljs-literal">true</span>    &#125;,    methods: &#123;        handleClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">this</span>.show = !<span class="hljs-built_in">this</span>.show        &#125;    &#125;&#125;)</code></pre><p><code>v-if</code>：</p><ul><li>判断指令</li><li>当<code>show</code>为<code>true</code>时，Hello Vue显示</li><li><code>show</code>为<code>false</code>时，Hello Vue隐藏</li><li>隐藏时，会把元素从<code>DOM</code>中删除</li></ul><p><strong>v-show</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>Hello Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        show: <span class="hljs-literal">true</span>    &#125;,    methods: &#123;        handleClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">this</span>.show = !<span class="hljs-built_in">this</span>.show        &#125;    &#125;&#125;)</code></pre><p><code>v-show</code>：</p><ul><li>作用与<code>v-if</code>差不多，唯一不同的是不会删除元素，而是给元素添加<code>display:none</code>属性 </li></ul><p><strong>v-for</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&quot;#root&quot;</span>,    data: &#123;        list: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]    &#125;,&#125;)</code></pre><p><code>v-for</code>：</p><ul><li>循环数据项 </li><li>循环<code>list</code>中的数据，并把每次循环的数据放到<code>li</code>元素中</li><li>需要添加<code>key</code>属性，并且每个<code>key</code>的值不能相同</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React基本概念和用法(一)</title>
    <link href="/posts/8b569266/index.html"/>
    <url>/posts/8b569266/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="React安装"><a href="#React安装" class="headerlink" title="React安装"></a>React安装</h2><p><code>React.js</code>不能单独使用，因为<code>React.js </code>不管在开发阶段生产阶段都需要工具和库辅助， 可以使用React官网推荐的<code>create-react-app</code> React脚手架工具，可以一键生成项目目录，开箱即用</p><p>在安装React之前需要安装<code>Node.js</code>环境和<code>npm</code></p><p><img src="https://files.alexhchu.com/2020/10/27/531c44f9cc0b5.png" alt="image-20201027171023426"></p><p>Node.js环境安装好后，安装<code>React</code>脚手架工具</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> -g <span class="hljs-keyword">create</span>-react-app</code></pre><p>安装好后运行<code>create-react-app</code> 的命令来创建一个项目目录</p><pre><code class="hljs dsconfig"><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">hello-react</span></code></pre><blockquote><p>这条命令帮我们创建名为 <code>hello-react</code>的项目文件，并安装项目所需要的依赖</p></blockquote><p>通过<code>npm</code>启动项目</p><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> hello-reactnpm <span class="hljs-built_in">start</span></code></pre><p>运行后会自动打开浏览器，可以看到项目运行成功后的界面</p><p><img src="https://files.alexhchu.com/2020/10/27/1055916548b79.png" alt="image-20201027172404521"></p><p>看到这个页面说明<code>React</code>已经安装成功</p><h2 id="使用JSX来操作页面"><a href="#使用JSX来操作页面" class="headerlink" title="使用JSX来操作页面"></a>使用JSX来操作页面</h2><p>先看一个示例代码</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render () &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;h1&gt;kkfive.com&lt;/h1&gt;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(  &lt;Header /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>在首行我们从<code>react</code>引入的<code>React</code>和<code>React.js</code>组件父<code>Component</code> ，以后只要写<code>React</code>的组件，都必须引入这两个东西</p><p>在第二行在<code>react-dom</code>中引入了<code>ReactDOM</code>，<code>ReactDOM</code>可以帮助我们把 <code>React</code> 组件渲染到页面上去</p><h3 id="JSX原理"><a href="#JSX原理" class="headerlink" title="JSX原理"></a>JSX原理</h3><p><code>JSX</code> 是 <code>JavaScript</code> 语言的一种语法扩展，长得像 HTML，但并不是 HTML</p><ul><li>它可以作为值使用</li><li>它也不是HTML</li><li>它可以配合JavaScript 表达式一起使用</li><li>它并不是字符串</li><li>JSX 在编译的时候会变成相应的 JavaScript 对象描述</li></ul><p>J<code>SX</code>可以让 <code>JavaScript</code> 语言能够支持这种直接在 <code>JavaScript</code> 代码里面编写类似 <code>HTML </code>标签结构的语法，编译的过程会把类似 <code>HTML</code> 的 <code>JSX</code> 结构转换成 <code>JavaScript </code>的对象结构。简单的说 <strong><em>所谓的 JSX 其实就是 JavaScript 对象</em></strong></p><p>理解这种表示HTML结构的信息对象后，就可以去构造真正的DOM元素，然后将这个DOM元素放在页面中，这就是<code>ReactDOM.render</code> 的作用</p><pre><code class="hljs javascript">ReactDOM.render(  &lt;Header /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p><code>ReactDOM.render</code> 的作用是把组件渲染并且构造成DOM树，然后插入到页面特定的元素中</p><p>整个执行过程如下图</p><p><img src="https://files.alexhchu.com/2020/10/27/d392df4790ae9.png" alt="image-20201027180618629"></p><h2 id="组件的redner方法"><a href="#组件的redner方法" class="headerlink" title="组件的redner方法"></a>组件的redner方法</h2><p>在编写<code>React.js</code>组件时，一般都需要继承<code>Component</code>，一个组件类必须要有一个<code>render</code>方法，这个<code>render</code>方法返回一个<code>JSX</code>元素</p><blockquote><p>注意：返回的JSX元素必须要有一个外层元素包裹，返回并列的多个JSX元素是错误的</p></blockquote><p><strong>错误写法</strong></p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;第一个&lt;/div&gt;    &lt;div&gt;第二个&lt;/div&gt;  )&#125;</code></pre><p><strong>正确写法</strong></p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;div&gt;第一个&lt;/div&gt;      &lt;div&gt;第二个&lt;/div&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="表达式插入"><a href="#表达式插入" class="headerlink" title="表达式插入"></a>表达式插入</h3><p>在<code> JSX</code> 当中可以插入 <code>JavaScript</code> 的表达式，表达式返回的结果会渲染到页面上。表达式用 <code>&#123;&#125;</code> 包裹</p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">const</span> test = <span class="hljs-string">&#x27;Word&#x27;</span>  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;Hello &#123;test&#125;&lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><p>页面上就会显示 <strong>”Hello Word “</strong>，<code>&#123;&#125;</code>中也可以写成一个函数表达式</p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;Hello &#123;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Word&#x27;</span>&#125;)()&#125;&lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><blockquote><p>总结：{}可以放任何的JavaScript代码，包括变量，计算，函数等等</p></blockquote><p>表达式还可以作用在标签的属性上</p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&#x27;header&#x27;</span>  <span class="hljs-keyword">return</span> (    &lt;div className=&#123;className&#125;&gt;      &lt;h1&gt;kkfive.com&lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><p>上述代码为<code>div</code>标签添加一个<code>header</code>类名</p><blockquote><p>在React.js中不能直接使用class给元素添加类型，因为class是JavaScript中的关键字，所以需要替换成className来给元素添加类名</p></blockquote><h3 id="条件返回"><a href="#条件返回" class="headerlink" title="条件返回"></a>条件返回</h3><p>因为<code>&#123;&#125;</code>可以放置任何表达式，所以也可以放<code>JSX</code>，那么可以在<code>render</code>函数内部根部不同条件返回的不同的<code>JSX</code></p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">const</span> isFun = <span class="hljs-literal">true</span>  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;        Hello        &#123;isFun          ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span> LiSi<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>          : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Zhang San <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>        &#125;      &lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><p>如果在表达式里面返回<code>null</code>，那么什么都不会显示，等于忽略表达式，根据此特性可以实现显示或者隐藏元素功能</p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">const</span> isFun = <span class="hljs-literal">true</span>  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;        Hello        &#123;isFun          ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span> Word<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>          : <span class="hljs-literal">null</span>        &#125;      &lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><p><code>isFun</code>为<code>true</code>的时候显示<code> &lt;strong&gt; Word&lt;/strong&gt;</code>  为<code>false</code>的时候就隐藏</p><h3 id="JSX元素变量"><a href="#JSX元素变量" class="headerlink" title="JSX元素变量"></a>JSX元素变量</h3><p><code>JSX</code>元素可以像<code>JavaScript</code>对象一样，可以赋值变量，作为函数参数传递或者作为函数的返回值</p><pre><code class="hljs javascript">render () &#123;  <span class="hljs-keyword">const</span> isFun = <span class="hljs-literal">true</span>  <span class="hljs-keyword">const</span> LS = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span> Li Si<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>  <span class="hljs-keyword">const</span> ZS = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> Zhang San<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;        Hello        &#123;isFun ? LS : ZS&#125;      &lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><pre><code class="hljs javascript">renderGoodWord (Ls, ZS) &#123;  <span class="hljs-keyword">const</span> isFun = <span class="hljs-literal">true</span>  <span class="hljs-keyword">return</span> isFun ? Ls : ZS&#125;render () &#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;h1&gt;        Hello        &#123;<span class="hljs-built_in">this</span>.renderGoodWord(          &lt;strong&gt; Li Si&lt;/strong&gt;,          &lt;span&gt; Zhang San&lt;/span&gt;        )&#125;      &lt;/h1&gt;    &lt;/div&gt;  )&#125;</code></pre><h2 id="组件的组合，嵌套和组件树"><a href="#组件的组合，嵌套和组件树" class="headerlink" title="组件的组合，嵌套和组件树"></a>组件的组合，嵌套和组件树</h2><h3 id="组合-嵌套"><a href="#组合-嵌套" class="headerlink" title="组合/嵌套"></a>组合/嵌套</h3><p>假设现在有两个组件 <code>Title</code> 和 <code>Header</code>，并且在 <code>Header</code> 组件中使用 <code>Title</code> 组件</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render () &#123;    <span class="hljs-keyword">return</span> (      &lt;h1&gt;Hello Word&lt;/h1&gt;    )  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render () &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;Title /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>React会在 <code>&lt;Title /&gt; </code>所有在的位置把<code>Title</code> 组件中<code>render</code>方法里的JSX内容渲染</p><p>也就是说 <code>&lt;h1&gt;Hello Word&lt;/h1&gt;</code> 会显示在<code>&lt;Title /&gt;</code>的位置上</p><p><img src="https://files.alexhchu.com/2020/10/27/c329c1f364d1b.png" alt="image-20201027193315234"></p><p>如果连续使用三个<code>&lt;Title /&gt;</code>，那么  <code>&lt;h1&gt;Hello Word&lt;/h1&gt;</code> 就会显示三遍</p><pre><code class="hljs apache"><span class="hljs-section">&lt;div&gt;</span>  <span class="hljs-section">&lt;Title /&gt;</span>  <span class="hljs-section">&lt;Title /&gt;</span>  <span class="hljs-section">&lt;Title /&gt;</span><span class="hljs-section">&lt;/div&gt;</span></code></pre><p><img src="https://files.alexhchu.com/2020/10/27/da36132b1701d.png" alt="image-20201027193416736"></p><p>这样可以提高组件的复用性和灵活性</p><blockquote><p>注意：自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头</p></blockquote><h3 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h3><p>创建三个组件<code>Header</code>，<code>Main</code>，``Footer<code>，然后由一个</code>Index`组件把他们组合起来</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;Title /&gt;        &lt;h2&gt;This is Header&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;h2&gt;This is Main&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Footer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;h2&gt;This is Footer&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;Header /&gt;        &lt;Main /&gt;        &lt;Footer /&gt;      &lt;/div&gt;    );  &#125;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Index</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>));</code></pre><p>打开页面会显示</p><p><img src="https://files.alexhchu.com/2020/10/27/aa93a3c2acc74.png" alt="image-20201027193953040"></p><p>组件可以和组件结合在一起使用，组件可以在内部使用别的组件，组件之间这样的嵌套，会形成一个组件树</p><p><img src="https://files.alexhchu.com/2020/10/27/7c5be7c77bf5a.png" alt="image-20201027194136142"></p><p><code>Index</code>中用了<code>Header</code>、<code>Main</code>、<code>Footer</code>，然后<code>Header</code>又使用了 <code>Title</code></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa2 请求数据获取</title>
    <link href="/posts/1bc3ae7b/index.html"/>
    <url>/posts/1bc3ae7b/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="GET请求数据获取"><a href="#GET请求数据获取" class="headerlink" title="GET请求数据获取"></a>GET请求数据获取</h2><p>在<code>koa</code>中，获取GET请求数据是从<code>koa</code>中<code>equest</code>对象中的<code>query</code>方法或<code>querystring</code>方法，<code>query</code>返回是格式化好的参数对象，<code>querystring</code>返回的是请求字符串，因为<code>ctx</code>对<code>request</code>的<code>API</code>有直接引用的方式，所以获取<code>GET</code>请求数据有两个方法。</p><ul><li>1.从上下文中直接获取<ul><li>请求对象<code>ctx.query</code>，返回结果如 { a:1, b:2 }</li><li>请求字符串 <code>ctx.querystring</code>，返回结果如 a=1&amp;b=2</li></ul></li><li>2.从上下文的<code>request</code>对象中获取<ul><li>请求对象<code>ctx.request.query</code>，返回结果如 { a:1, b:2 }</li><li>请求字符串 <code>ctx.request.querystring</code>，返回结果如a=1&amp;b=2</li></ul></li></ul><p>​    <strong>示例代码</strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;  <span class="hljs-keyword">let</span> url = ctx.url;  <span class="hljs-comment">// 从上下文的request对象中获取</span>  <span class="hljs-keyword">let</span> request = ctx.request;  <span class="hljs-keyword">let</span> req_query = request.query;  <span class="hljs-keyword">let</span> req_querystring = request.querystring;  <span class="hljs-comment">// 从上下文中直接获取</span>  <span class="hljs-keyword">let</span> ctx_query = ctx.query;  <span class="hljs-keyword">let</span> ctx_querystring = ctx.querystring;  ctx.body = &#123;    url,    req_query,    req_querystring,    ctx_query,    ctx_querystring,  &#125;;&#125;);app.listen(<span class="hljs-number">3000</span>);</code></pre><p><strong>执行程序</strong></p><p>执行<code>node index.js</code>   然后访问  <a href="http://localhost:3000/page/user?a=1&amp;b=2">http://localhost:3000/page/user?a=1&amp;b=2</a>  页面会出现以下结果</p><p><img src="https://files.alexhchu.com/2020/10/22/7628e9c3b4152.png" alt="image-20201022110128596"></p><h2 id="koa-bodyparser中间件"><a href="#koa-bodyparser中间件" class="headerlink" title="koa-bodyparser中间件"></a>koa-bodyparser中间件</h2><p>对于POST的请求，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中</p><p><strong>安装koa-bodyparser</strong></p><p><code>npm i koa-bodyparser</code></p><p><strong>示例代码</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa-bodyparser&quot;</span>);<span class="hljs-comment">// 使用ctx.body解析中间件</span>app.use(bodyParser());app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;  <span class="hljs-keyword">if</span> (ctx.url === <span class="hljs-string">&quot;/&quot;</span> &amp;&amp; ctx.method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;    <span class="hljs-comment">// 当GET请求时候返回表单页面</span>    <span class="hljs-keyword">let</span> html = <span class="hljs-string">`</span><span class="hljs-string">      &lt;h1&gt;demo&lt;/h1&gt;</span><span class="hljs-string">      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;</span><span class="hljs-string">        &lt;p&gt;用户名&lt;/p&gt;</span><span class="hljs-string">        &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><span class="hljs-string">        &lt;p&gt;昵称&lt;/p&gt;</span><span class="hljs-string">        &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;</span><span class="hljs-string">        &lt;p&gt;邮箱&lt;/p&gt;</span><span class="hljs-string">        &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;</span><span class="hljs-string">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><span class="hljs-string">      &lt;/form&gt;</span><span class="hljs-string">    `</span>;    ctx.body = html;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx.url === <span class="hljs-string">&quot;/&quot;</span> &amp;&amp; ctx.method === <span class="hljs-string">&quot;POST&quot;</span>) &#123;    <span class="hljs-comment">// 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来</span>    <span class="hljs-keyword">let</span> postData = ctx.request.body;    ctx.body = postData;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 其他请求显示404</span>    ctx.body = <span class="hljs-string">&quot;&lt;h1&gt;404！！！/(ㄒoㄒ)/~~&lt;/h1&gt;&quot;</span>;  &#125;&#125;);app.listen(<span class="hljs-number">3000</span>);</code></pre><p><strong>执行程序</strong></p><p>执行<code>node index.js</code>  然后访问 <a href="http://localhost:3000/">http://localhost:3000/</a> </p><p><img src="https://files.alexhchu.com/2020/10/22/0f511ecea4d2d.png" alt="image-20201022112216854"></p><p>提交表单触发POST请求</p><p><img src="https://files.alexhchu.com/2020/10/22/b2b47cf36e3bb.png" alt="image-20201022112253981"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Koa2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs 数据库操作</title>
    <link href="/posts/d86770b1/index.html"/>
    <url>/posts/d86770b1/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>要在<code>NodeJs</code>中连接数据库需要去<code>npm</code>中安装操作数据库的模块，以<code>mysql</code>为例，在<code>npm</code>中安装<code>mysql2</code>模块</p><p>为何使用<code>mysql2</code>而不是经典的<code>mysql</code>库</p><ul><li><code>mysql2</code>的性能更好</li><li><code>myslq2</code>支持<code>promise</code>操作，自带<code>Promise</code>包装器，可以直接使用<code>async/await</code>语法</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>安装</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i mysql<span class="hljs-number">2</span></code></pre><p><strong>连接数据库</strong></p><pre><code class="hljs routeros">const<span class="hljs-built_in"> connection </span>= mysql2.createConnection(&#123;  host: <span class="hljs-string">&quot;localhost&quot;</span>,  user: <span class="hljs-string">&quot;数据库用户名&quot;</span>,  password: <span class="hljs-string">&quot;数据库密码&quot;</span>,  database: <span class="hljs-string">&quot;数据库名称&quot;</span>,&#125;);</code></pre><p><strong>查询</strong></p><pre><code class="hljs javascript">connection.query(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>,<span class="hljs-function">(<span class="hljs-params">err, results</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(err)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(err);    &#125;    <span class="hljs-built_in">console</span>.log(results);&#125;);</code></pre><blockquote><p>results包含服务器返回的行</p></blockquote><p><strong>插入</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [rs] = <span class="hljs-keyword">await</span> conn.query(  <span class="hljs-string">&#x27;insert into `user` values (0,?,?,?,now())&#x27;</span>,  [name, password, email])<span class="hljs-keyword">const</span> id = rs.insertId <span class="hljs-comment">// 获取自增ID</span></code></pre><blockquote><p>插入数据采用了占位符方式</p></blockquote><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li><p>创建连接池</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pool = mysql.createPool(&#123;...&#125;)</code></pre></li><li><p>进程退出时自动关闭连接池</p><pre><code class="hljs javascript">process.on(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-keyword">async</span> (code) =&gt; &#123;  <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">await</span> pool.end() &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;&#125;)</code></pre></li><li><p>简单使用<br>直接用<code>pool.query(...)</code>和<code>pool.execute(...)</code>即可，相当于从池中获取一条连接，然后执行查询</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基本操作</title>
    <link href="/posts/8db63ddf/index.html"/>
    <url>/posts/8db63ddf/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="连接Mysql"><a href="#连接Mysql" class="headerlink" title="连接Mysql"></a>连接Mysql</h2><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>在命令行连接mysql的参数如下：</p><table><thead><tr><th>选项</th><th>说明</th><th>默认</th></tr></thead><tbody><tr><td>-u</td><td>帐号</td><td>当前系统同名帐号</td></tr><tr><td>-p</td><td>密码</td><td></td></tr><tr><td>-P</td><td>连接端口</td><td>3306</td></tr><tr><td>-h</td><td>主机地址</td><td>127.0.0.1</td></tr><tr><td>-e</td><td>执行sql指令</td><td></td></tr></tbody></table><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p><strong>连接服务器</strong></p><pre><code class="hljs mysql">mysql -uroot -p -P3306 -h 127.0.0.1</code></pre><p>连接本地数据库时可以使用默认值</p><pre><code class="hljs mysql">mysql -uroot -p</code></pre><p>使用<code>-e</code> 执行SQL语句</p><pre><code class="hljs mysql">mysql -uroot -proot -e&quot;show databases;&quot;</code></pre><p><strong>退出连接</strong></p><p>命令行下执行exit可通出当前连接</p><pre><code class="hljs mysql">exit</code></pre><h3 id="执行与取消"><a href="#执行与取消" class="headerlink" title="执行与取消"></a>执行与取消</h3><p>每条SQL指令以<code>;</code>结束，按回车键后执行该条语句。</p><pre><code class="hljs mysql">show databases;</code></pre><p><strong>放弃语句</strong></p><p>在SQL后使用 <code>\c</code>表示取消本条SQL，后面不需要写 <code>;</code>。</p><pre><code class="hljs mysql">show databases \c</code></pre><h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><strong>数据库列表</strong></p><p>使用以下命令可以得到当前服务器中的所有数据库。</p><pre><code class="hljs mysql">show databases;</code></pre><p><strong>创建新库</strong></p><p>下面是创建数据库 <code>kkfive</code> 并设置字符集为 utf8。</p><pre><code class="hljs mysql">CREATE DATABASE  CHARSET utf8;</code></pre><p><strong>查看数据库</strong></p><pre><code class="hljs mysql">show create database kkfive;</code></pre><p><strong>删除数据库</strong></p><pre><code class="hljs mysql">drop database kkfive;</code></pre><p>为了防止删除不存在的数据库报错</p><pre><code class="hljs mysql">drop database if exists kkfive;</code></pre><p><strong>选择数据库</strong></p><p>数据库主要是对表操作，选择数据库后可以省掉每次指定数据库的麻烦。</p><pre><code class="hljs mysql">use kkfive</code></pre><h3 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h3><p>有时需要把外部的SQL文件导入到服务器中，图像化的数据库管理软件都支持导入</p><p><strong>创建文件</strong></p><p>我们创建 <code>test.sql</code>文件内容如下</p><pre><code class="hljs mysql">create database muyi charset utf8;SHOW DATABASES;</code></pre><p><strong>外部导入</strong></p><pre><code class="hljs mysql">mysql -uroot -p &lt; test.sql</code></pre><p><strong>连接后导入</strong></p><pre><code class="hljs mysql">mysql -uroot -p&gt; source test.sql</code></pre><h2 id="数据表管理"><a href="#数据表管理" class="headerlink" title="数据表管理"></a>数据表管理</h2><p>可以把数据库理解为文件夹，数据表理解为文件，数据表是真正储存数据的地方。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>创建数据表</strong></p><pre><code class="hljs mysql">create table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;</code></pre><p>以上语句创建表 <code>class</code> 字段说明如下：</p><ul><li>字段 id 为主键自增</li><li>字段 cname 为字符串类型varchar 并不允许为 null</li><li>字段 description 为可为null 字符串</li><li>字符集为 utf8 ，如果不设置将继承数据库字符集</li></ul><p><strong>添加测试数据</strong></p><pre><code class="hljs mysql">INSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;JavaScript&#39;);INSERT INTO class (cname) VALUES(&#39;Mysql&#39;);</code></pre><p>因为 description 设置为null 所以第二个记录没有设置值时使用默认的null值。</p><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>根据已经存在的表结构创建新表</p><pre><code class="hljs mysql">create table muyi like class;</code></pre><p>复制其他表的数据</p><pre><code class="hljs mysql">insert into muyi select * from class;</code></pre><p>只复制批定字段</p><pre><code class="hljs mysql">insert into muyi (cname) select cname from class;</code></pre><p>复制表时同时复制数据</p><pre><code class="hljs mysql">create table fwjs select * from class;</code></pre><p>下面是只复制指定字段，并为不同名字段起别名</p><pre><code class="hljs mysql">create table fw (id int primary key AUTO_INCREMENT,name varchar(30)) select id,cname as name from class;</code></pre><p>删除数据表</p><pre><code class="hljs mysql">DROP TEMPORARY TABLE IF EXISTS fw;</code></pre><h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>临时表是用于储存临时数据表表，会在数据库连接中断时自动删除。</p><ul><li>可以与普通表同名，优先级高于普通表</li><li>连接终端时自动删除</li></ul><pre><code class="hljs mysql">create TEMPORARY TABLE class_names SELECT * from class;select * from class_names;</code></pre><p>删除临时表</p><pre><code class="hljs mysql">DROP TEMPORARY TABLE IF EXISTS class_names;</code></pre><blockquote><p>当然开发中我们更喜欢将临时数据放在缓存或会话中，以上只是介绍这个mysql特性。</p></blockquote><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h3><p>为了进行查询实例操作我们创建以下表</p><pre><code class="hljs mysql">CREATE TABLE stu (id int PRIMARY KEY AUTO_INCREMENT,sname char(30),class_id int default null,age smallint default null)INSERT INTO stu(sname,class_id,age) VALUES(&#39;小明&#39;,1,20),(&#39;张三&#39;,2,32),(&#39;李四&#39;,3,null),(&#39;小刘&#39;,null,46);</code></pre><h3 id="字段处理"><a href="#字段处理" class="headerlink" title="字段处理"></a>字段处理</h3><p>查询所有字估数据</p><pre><code class="hljs mysql">select * from class;</code></pre><p>查询指定字段数据并排序字段</p><pre><code class="hljs mysql">select description,cname from class;</code></pre><h3 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h3><p>根据条件查询</p><pre><code class="hljs mysql">select * from class where cname &#x3D; &#39;php&#39;</code></pre><p>查询包含关键词的数据</p><pre><code class="hljs mysql">select * from class where description like &#39;%p%&#39;;</code></pre><p>合并列返回查询结果</p><pre><code class="hljs mysql">select CONCAT(id,cname) as &#39;class_info&#39; FROM class;</code></pre><p>指定多条件查询</p><pre><code class="hljs mysql">SELECT * FROM class where id&gt;1 and cname &#x3D; &#39;php&#39;</code></pre><p>查找一班或姓张的同学</p><pre><code class="hljs mysql">select * from stu where class_id &#x3D;1 or sname like &#39;%张%&#39;</code></pre><p>介绍中不包含php的班级</p><pre><code class="hljs mysql">SELECT * from class WHERE description NOT LIKE &#39;%php%&#39;;</code></pre><p>查询学生所在班级编号，并去除重复值</p><pre><code class="hljs mysql">SELECT DISTINCT class_id from stu ;</code></pre><p>查询年龄在20~35岁的同学</p><pre><code class="hljs mysql">select * from stu where age BETWEEN 20 and 35;</code></pre><p>查找不在30~35岁间的同学</p><pre><code class="hljs mysql">select * from stu where age NOT BETWEEN 30 and 35;</code></pre><p>查找2、3班的所有同学</p><pre><code class="hljs mysql">SELECT * FROM stu where class_id IN(2,3);</code></pre><p>查找除了1、3班的同学</p><pre><code class="hljs mysql">select * from stu where class_id NOT IN (1,3);</code></pre><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><p>查询没有分配班级的学生姓名</p><pre><code class="hljs mysql">select sname from stu where class_id is null;</code></pre><p>查询已经分配班级的学生信息</p><pre><code class="hljs mysql">SELECT * from stu where class_id is not null;</code></pre><p>查询结果中对没分配班级的学生显示未分配</p><pre><code class="hljs mysql">select sname,if(class_id is null,&#39;未分配&#39;,class_id) from stu;# 也可以使用IFNULl 函数简化操作select sname,ifnull (class_id ,&#39;未分配&#39;) from stu;</code></pre><h3 id="排序结果"><a href="#排序结果" class="headerlink" title="排序结果"></a>排序结果</h3><p>按学生年龄从大到小排序</p><pre><code class="hljs mysql">SELECT * FROM stu order by age desc;</code></pre><p>班级从大到小排序，相同班级的同学年龄从小到大排序</p><pre><code class="hljs mysql">select * from stu order by class_id DESC,age ASC;</code></pre><p>随机获取一名同学</p><pre><code class="hljs mysql">SELECT * from stu order by RAND() limit 1;</code></pre><p>最后报名的同学</p><pre><code class="hljs mysql">select * from stu order by id desc limit 1</code></pre><p>每二和第三报名的同学</p><pre><code class="hljs mysql"># Limit 是从零开始的SELECT * FROM stu order by id ASC limit 1,2;</code></pre><p>查找2班年龄最小的同学</p><pre><code class="hljs mysql">SELECT * from stu where class_id &#x3D;2 and age is not null order by age asc limit 1;</code></pre><p>以上代码结果不准确，因为可能有同年龄的同学，所以可以使用子查询操作。</p><pre><code class="hljs mysql">select * from stu where age &#x3D; (SELECT age from stu where class_id &#x3D;2 and age is not null order by age asc limit 1)</code></pre><blockquote><p>多表操作，子查询操作会在其他章节详细讲解</p></blockquote><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>将班级为2的学生改为班级3</p><pre><code class="hljs mysql">UPDATE stu SET class_id &#x3D; 3 WHERE class_id &#x3D; 2;</code></pre><p>2班年龄小于20岁的同学年龄设置为NULL</p><pre><code class="hljs mysql">UPDATE stu SET age &#x3D; null WHERE class_id&#x3D;2 AND age&lt;20;</code></pre><p>将年龄小于20岁的同学年龄加10岁</p><pre><code class="hljs mysql">UPDATE stu SET age&#x3D; age+20 WHERE age&lt;20;</code></pre><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>删除所有年龄小于20的同学</p><pre><code class="hljs mysql">DELETE FROM stu WHERE age&lt;20;</code></pre><p>删除所有年龄小在30并没有班级的同学</p><pre><code class="hljs mysql">DELETE FROM stu WHERE class_id IS NULL;</code></pre><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>添加一条记录</p><pre><code class="hljs mysql">INSERT INTO stu SET sname &#x3D; &#39;小明&#39;,age&#x3D;22,class_id&#x3D;1;</code></pre><p>添加多条记录</p><pre><code class="hljs mysql">INSERT INTO stu (sname,class_id,age) VALUES(&#39;小明&#39;,2,32),(&#39;小张&#39;,3,45);</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa2框架学习基本语法和使用</title>
    <link href="/posts/496507a6/index.html"/>
    <url>/posts/496507a6/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="Koa框架简介"><a href="#Koa框架简介" class="headerlink" title="Koa框架简介"></a>Koa框架简介</h2><p><code>Koa</code> 是一个新的 <code>web</code> 框架，由 <code>Express</code> 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 <code>async</code> 函数，<code>Koa</code> 帮你丢弃回调函数，并有力地增强错误处理。 <code>Koa</code> 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs text"># 初始化package.jsonnpm init# 安装koa2 npm install koa</code></pre><h2 id="创建一个简单的web服务"><a href="#创建一个简单的web服务" class="headerlink" title="创建一个简单的web服务"></a>创建一个简单的web服务</h2><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()app.use( <span class="hljs-keyword">async</span> ( ctx,next ) =&gt; &#123;  ctx.body = <span class="hljs-string">&#x27;hello world&#x27;</span>&#125;)app.listen(<span class="hljs-number">3000</span>)</code></pre><h2 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h2><p>以下是官方文档中的一个例子</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-comment">// logger</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-keyword">await</span> next();  <span class="hljs-keyword">const</span> rt = ctx.response.get(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.method&#125;</span> <span class="hljs-subst">$&#123;ctx.url&#125;</span> - <span class="hljs-subst">$&#123;rt&#125;</span>`</span>);&#125;);<span class="hljs-comment">// x-response-time</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-keyword">await</span> next();  <span class="hljs-keyword">const</span> ms = <span class="hljs-built_in">Date</span>.now() - start;  ctx.set(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>);&#125;);<span class="hljs-comment">// response</span>app.use(<span class="hljs-keyword">async</span> ctx =&gt; &#123;  ctx.body = <span class="hljs-string">&#x27;Hello World&#x27;</span>;&#125;);app.listen(<span class="hljs-number">3000</span>);</code></pre><p>文档中给出的解释是：当请求开始时首先请求流通过 <code>x-response-time</code> 和 <code>logging</code> 中间件，然后继续移交控制给 <code>response</code> 中间件。当一个中间件调用 <code>next()</code> 则该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为</p><p>简单来说，当执行的中间件中调用的<code>next()</code>方法，则会停止当前中间件的执行，而去执行下游的中间件，如果下游的中间件中也调用了<code>next()</code>方法，则也会停止执行继续执行下游的中间件，以此类推直到下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为</p><p>看一个简单的例子</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-comment">// one</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-keyword">await</span> next();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);&#125;);<span class="hljs-comment">// two</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);  <span class="hljs-keyword">await</span> next();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);&#125;);<span class="hljs-comment">// three</span>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>);  ctx.body = <span class="hljs-string">&quot;Hello World&quot;</span>;&#125;);app.listen(<span class="hljs-number">3000</span>);</code></pre><blockquote><p>代码执行结果：1 3 5 4 2 </p></blockquote><p><strong>执行顺序</strong></p><ul><li>首先执行<code>one</code>中间件</li><li>输出结果1后，遇到<code>next(</code>)方法，停止执行，开始执行下游中间件</li><li><code>two</code>中间件输出结果3后，再次遇到<code>next()</code>方法，停止执行，开始执行下游中间件</li><li><code>three</code>中间件输出结果5后，执行完成，并且没有更多的下游中间件，开始恢复执行其上游行为，执行<code>two</code>中间件没有执行的代码。</li></ul><p>上述过程也可以通过”洋葱模型“来解释中间件执行顺序</p><p><img src="https://files.alexhchu.com/2020/10/05/daba169204d99.png" alt="洋葱模型"></p><h2 id="Application对象"><a href="#Application对象" class="headerlink" title="Application对象"></a>Application对象</h2><p><strong>application是koa的实例  简写app</strong></p><h3 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h3><p>给创建的<code>Koa</code>应用程序绑定端口，以下是一个无作用的<code> Koa</code> 应用程序被绑定到 <code>3000</code> 端口：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();app.listen(<span class="hljs-number">3000</span>);</code></pre><h3 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h3><p>将给定的中间件方法添加到此应用程序。<code>app.use()</code> 返回 <code>this</code>, 因此可以链式表达.</p><pre><code class="hljs javascript">app.use(someMiddleware)app.use(someOtherMiddleware)app.listen(<span class="hljs-number">3000</span>)</code></pre><p>等同于</p><pre><code class="hljs javascript">app.use(someMiddleware)  .use(someOtherMiddleware)  .listen(<span class="hljs-number">3000</span>)</code></pre><h3 id="app-on"><a href="#app-on" class="headerlink" title="app.on()"></a>app.on()</h3><p><code>app.on()</code>的作用是可以添加一个 “error” 事件侦听器，来对错误进行处理</p><pre><code class="hljs javascript">app.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;  log.error(<span class="hljs-string">&#x27;server error&#x27;</span>, err)&#125;);</code></pre><p>如果 req/res 期间出现错误，并且 <em>无法</em> 响应客户端，<code>Context</code>实例仍然被传递：</p><pre><code class="hljs javascript">app.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, ctx</span>) =&gt;</span> &#123;  log.error(<span class="hljs-string">&#x27;server error&#x27;</span>, err, ctx)&#125;);</code></pre><h2 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文(Context)"></a>上下文(Context)</h2><p>Koa Context 将 node 的 <code>request</code> 和 <code>response</code> 对象封装到单个对象中，每个_ 请求都将创建一个 <code>Context</code>，并在中间件中作为接收器引用，标识符为 <code>ctx</code> </p><pre><code class="hljs javascript">app.use(<span class="hljs-keyword">async</span> ctx =&gt; &#123;  ctx; <span class="hljs-comment">// 这是 Context</span>  ctx.request; <span class="hljs-comment">// 这是 koa Request</span>  ctx.response; <span class="hljs-comment">// 这是 koa Response</span>&#125;);</code></pre><h3 id="ctx-req"><a href="#ctx-req" class="headerlink" title="ctx.req"></a>ctx.req</h3><p>Node 的 <code>request</code> 对象.</p><h3 id="ctx-res"><a href="#ctx-res" class="headerlink" title="ctx.res"></a>ctx.res</h3><p>Node 的 <code>response</code> 对象.</p><p><strong>注意</strong></p><p>绕过 Koa 的 response 处理是 <strong>不被支持的</strong>. 应避免使用以下 node 属性：</p><ul><li><code>res.statusCode</code></li><li><code>res.writeHead()</code></li><li><code>res.write()</code></li><li><code>res.end()</code></li></ul><h3 id="ctx-request"><a href="#ctx-request" class="headerlink" title="ctx.request"></a>ctx.request</h3><p>koa 的 <code>Request</code> 对象.</p><h3 id="ctx-response"><a href="#ctx-response" class="headerlink" title="ctx.response"></a>ctx.response</h3><p>koa 的 <code>Response</code> 对象.</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Koa2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs 文件操作</title>
    <link href="/posts/ab39f70d/index.html"/>
    <url>/posts/ab39f70d/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><p><code>HTTP</code>模块的作用是创建一个服务器，<code>HTTP</code>是Node的内置模块，不用在单独下载</p><p>使用<code>requier</code>指令来导入http模块，将实例化的<code>HTTP</code>赋值给<code>http</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);</code></pre><p>使用<code>http</code>模块的<code>createServer()</code> 方法创建服务器，使用<code>listen</code> 方法绑定端口号，<code>listen</code>方法接收两个个参数，第一个参数要绑定的端口号，第二个参数服务启动成功后执行的回调函数<code>createServer(</code>)方法有两个参数,<code>request</code>, <code>response</code>分别表示接收数据和响应数据，基本结构如以下代码</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  response.end(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);&#125;);</code></pre><p><code>response.end(&quot;hello&quot;)</code>向页面响应数据，访问<a href="http://localhost:3000/">http://localhost:3000/</a>  就可以看到响应的数据</p><p><img src="https://files.alexhchu.com/2020/09/25/2c3039caffbd1.png" alt="image-20200925200231905"></p><p>如果响应的数据为中文，则会出现乱码</p><p><img src="https://files.alexhchu.com/2020/09/25/465da338c39e2.png" alt="image-20200925202709457"></p><p>出现乱码的原因是头部编码，在响应前设置编码头信息就可以解决</p><pre><code class="hljs javascript">response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);</code></pre><h2 id="FS模块"><a href="#FS模块" class="headerlink" title="FS模块"></a>FS模块</h2><p><code>FS</code>模块的作用是用来读写文件，对文件进行交互的模块</p><p>通过<code>required</code>来引入模块</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);</code></pre><p><code>FS</code>模块中有两种才操作形式：同步和异步</p><ul><li>同步：会阻塞程序的进行，等文件全部读取完毕才会向下执行代码</li><li>异步：不会阻塞程序的进行，在读取文件的时候，可以进行其他的操作</li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><strong>同步操作</strong></p><p><code>fs.readFileSync</code>方法是同步来读取文件，首先创建一个txt文件，随便写点内容</p><p><img src="https://files.alexhchu.com/2020/09/25/50a0b6c1f8cbd.png" alt="image-20200925201404951"></p><p>然后通过<code>fs.readFileSync</code>来读取文件，并响应到页面中</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> res = fs.readFileSync(<span class="hljs-string">&quot;./1.txt&quot;</span>);  response.end(res);&#125;);server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);&#125;);</code></pre><p>访问<a href="http://localhost:3000/">http://localhost:3000/</a>  就可以看到文件中的内容</p><p><img src="https://files.alexhchu.com/2020/09/25/1e4df5f74353d.png" alt="image-20200925201655775"></p><p><strong>异步操作</strong></p><p><code>fs.readFile()</code>方法是来异步读取文件，异步和同步读取方法的区别就是是否带有<code>Sync</code>关键字，凡是加了<code>Sync</code>的方法同步操作，否则就是异步操作</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> res = fs.readFile(<span class="hljs-string">&quot;./1.txt&quot;</span>);  response.end(res);&#125;);server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);&#125;);</code></pre><p>访问<a href="http://localhost:3000/%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9C%8B%E5%88%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">http://localhost:3000/可以正常看到读取文件中的内容</a></p><p><img src="https://files.alexhchu.com/2020/09/25/1e4df5f74353d.png" alt="image-20200925201655775"></p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><code>fs.writeFileSync()</code>方法：接收四个参数 <code>fs.writeFile(file, data[, options], callback)</code></p><ul><li>file - 文件名或文件描述符</li><li>data - 要写入文件的数据</li><li>options - 该参数是一个对象,用来表明写入的行为<ul><li>r+ ： 读取文件</li><li>w+ ： 打开文件用于读写，会覆盖目标文件的原内容，如果文件不存在则创建文件</li><li>a ：追加写入，如果文件不存在则创建文件。</li></ul></li><li>callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);  fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;Hello world&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;w&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;      <span class="hljs-built_in">console</span>.log(err);    &#125;  &#125;);  response.end(<span class="hljs-string">&quot;你好&quot;</span>);&#125;);server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);&#125;);</code></pre><p>向2.txt文件中写入内容hello world，如果2.txt没有，那么系统会自动帮我们创建</p><p>打开2.txt就可以看到我们刚才写入的内容</p><p><img src="https://files.alexhchu.com/2020/09/25/fa515160f3897.png" alt="image-20200925213612961"></p><p>如果我们更改一下写入的内容，重新运行代码，会发现之前写入的内容消失了，而显示的是新写入的内容</p><pre><code class="hljs javascript">fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;w&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;      <span class="hljs-built_in">console</span>.log(err);    &#125;  &#125;);</code></pre><p><img src="https://files.alexhchu.com/2020/09/25/990be9b74c767.png" alt="image-20200925214449339"></p><p>这是因为我们使用的写入行为是<code>w</code>，会覆盖文件中的内容，将写入行为改为<code>a</code>就可以追加写入了</p><pre><code class="hljs javascript">fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;博客&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;a&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;      <span class="hljs-built_in">console</span>.log(err);    &#125;  &#125;);</code></pre><p><img src="https://files.alexhchu.com/2020/09/25/dbee4a29bb43f.png" alt="image-20200925214621462"></p><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><p>使用<code> fs.rename()</code> 或 <code>fs.renameSync()</code> 可以重命名文件。 第一个参数要被修改的文件名，第二个参数是新的文件名</p><p>现在将2.txt重命名为3.txt，代码如下</p><pre><code class="hljs javascript">fs.rename(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-built_in">console</span>.log(err);  &#125;&#125;);</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>fs.unlink()</code>方法可以删除指定的文件，该方法接收两个参数，第一个参数表示要删除的文件名，第二个参数为报错时运行的回调函数</p><p>现在将3.txt进行删除，代码如下</p><pre><code class="hljs javascript">fs.unlink(<span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(err);  &#125;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除成功&quot;</span>);&#125;);</code></pre><h3 id="流方式读取文件"><a href="#流方式读取文件" class="headerlink" title="流方式读取文件"></a>流方式读取文件</h3><p><code>fs.readFileSync</code>方法和<code>fs.writeFileSync()</code>方法适合拷贝一些小文件，但是如果想一次性把所有文件读取到内存再一次性写入到文件中这两种方法就不适合，对于大文件，我们只能读一点写一点，流方式非常适合大文件的读取</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);  fs.createReadStream(<span class="hljs-string">&quot;./1.txt&quot;</span>).pipe(fs.createWriteStream(<span class="hljs-string">&quot;./3.txt&quot;</span>));  response.end(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);&#125;);</code></pre><p>以上代码使用<code>fs.createReadStream()</code>方法创建第一个源文件只读数据流，使用<code>fs.createWriteStream()</code>方法创建了一个目标文件的只写数据流，使用<code>pipe</code>方法把两个数据流连接起来，整个读写过程如下图</p><p><img src="https://files.alexhchu.com/2020/09/27/b2ca4cab3eec1.png" alt="image-20200927110116025"></p><h2 id="PATH模块"><a href="#PATH模块" class="headerlink" title="PATH模块"></a>PATH模块</h2><p><code>PATH</code>模块的主要功能是用来处理路径的工具，可以简化路径的相关操作</p><ul><li><p><code>path.normalize</code></p><p>将传入的路径转换为标准路径，除了可以解析路径中的<code>.</code>和<code>..</code>外，还可以去除多余的斜杠</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> cache = &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">store</span>(<span class="hljs-params">key, value</span>) </span>&#123;    cache[path.normalize(key)] = value;&#125;store(<span class="hljs-string">&#x27;foo/bar&#x27;</span>, <span class="hljs-number">1</span>);store(<span class="hljs-string">&#x27;foo//baz//../bar&#x27;</span>, <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(cache);  <span class="hljs-comment">//  &#123; &quot;foo/bar&quot;: 2 &#125;</span></code></pre></li></ul><ul><li><p><code>path.extname</code></p><p>可以获取文件的后缀名，当我们需要根据不同文件的后缀名做不同操作时，可以使用该方法</p><pre><code class="hljs javascript">path.extname(<span class="hljs-string">&#x27;server.js&#x27;</span>); <span class="hljs-comment">// =&gt; &quot;.js&quot;</span></code></pre></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><ul><li><code>Buffer</code>是用来处理二进制数据的缓存区</li><li>除了读取文件获取<code>Buffer</code>以外，还可以直接构造</li><li><code>Buffer</code>将 JS 的数据处理能力从字符串扩展到了任意二进制数据</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bin = <span class="hljs-keyword">new</span> Buffer([ <span class="hljs-number">0x68</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6f</span> ]);</code></pre><p><code>Buffer</code>与字符串类似，可以用<code>length</code>属性获得字节长度，也可以使用<code>[]</code>方式去读指定位置的字节</p><pre><code class="hljs javascript">bin[<span class="hljs-number">0</span>]; <span class="hljs-comment">//  0x68;</span></code></pre><p><code>Buffer</code>与字符串可以相互转化，可以将指定的二进制数据转换为字符串</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = bin.toString(<span class="hljs-string">&#x27;utf-8&#x27;</span>); <span class="hljs-comment">// =&gt; &quot;hello&quot;</span></code></pre><h2 id="Stream-数据流"><a href="#Stream-数据流" class="headerlink" title="Stream (数据流)"></a>Stream (数据流)</h2><p>当内存中无法一次性存储需要处理的数据，可以改为一边读取一边处理的方法，这就需要用到数据流，NodeJs中可以使用 <code>Stream</code>来对数据流进行操作</p><p>所有的<code>Stream</code>对象都是<code>EventEmitter</code> 的实例。常用的事件有：</p><ul><li><code>data</code>：当有数据可读取时触发</li><li><code>end</code>：没有更多的数据可读取时触发</li><li><code>error</code>：在接收和写入过程中发生错误时触发</li><li><code>finish</code>：所有数据已被写入到底层系统时触发</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rs = fs.createReadStream(pathname);rs.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;    doSomething(chunk);&#125;);rs.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    cleanUp();&#125;);</code></pre><p>上述代码中<code>data</code>事件会一直触发，不管<code>doSomething</code>函数是否能处理过来,<code>createReadStream()</code>中有两个方法可以解决此问题</p><ul><li><code>rs.pause()</code> 暂停读取,会暂停data事件的触发，将流动模式转变非流动模式</li><li><code>rs.resume()</code>恢复data事件,继续读取，变为流动模式</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rs = fs.createReadStream(src);rs.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;    rs.pause();    doSomething(chunk, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        rs.resume();    &#125;);&#125;);rs.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    cleanUp();&#125;);</code></pre><p>上述代码给<code>doSomething</code>函数添加了一个回调函数，在处理数据前暂停数据读取，在处理后继续读取数据</p><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p><h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p><blockquote><p><strong>陷阱：</strong> 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</p></blockquote><h3 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h3><p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。</p><pre><code class="hljs latex">    A   / <span class="hljs-tag">\</span>  B   C / <span class="hljs-tag">\<span class="hljs-name"> </span></span>  <span class="hljs-tag">\</span>D   E   F</code></pre><h3 id="同步遍历"><a href="#同步遍历" class="headerlink" title="同步遍历"></a>同步遍历</h3><p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travel</span>(<span class="hljs-params">dir, callback</span>) </span>&#123;    fs.readdirSync(dir).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>&#123;        <span class="hljs-keyword">var</span> pathname = path.join(dir, file);        <span class="hljs-keyword">if</span> (fs.statSync(pathname).isDirectory()) &#123;            travel(pathname, callback);        &#125; <span class="hljs-keyword">else</span> &#123;            callback(pathname);        &#125;    &#125;);&#125;</code></pre><p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p><pre><code class="hljs text">- /home/user/    - foo/        x.js    - bar/        y.js    z.css</code></pre><p>使用以下代码遍历该目录时，得到的输入如下。</p><pre><code class="hljs javascript">travel(<span class="hljs-string">&#x27;/home/user&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pathname</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(pathname);&#125;);------------------------/home/user/foo/x.js/home/user/bar/y.js/home/user/z.css</code></pre><h3 id="异步遍历"><a href="#异步遍历" class="headerlink" title="异步遍历"></a>异步遍历</h3><p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travel</span>(<span class="hljs-params">dir, callback, finish</span>) </span>&#123;    fs.readdir(dir, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, files</span>) </span>&#123;        (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">i</span>) </span>&#123;            <span class="hljs-keyword">if</span> (i &lt; files.length) &#123;                <span class="hljs-keyword">var</span> pathname = path.join(dir, files[i]);                fs.stat(pathname, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) </span>&#123;                    <span class="hljs-keyword">if</span> (stats.isDirectory()) &#123;                        travel(pathname, callback, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                            next(i + <span class="hljs-number">1</span>);                        &#125;);                    &#125; <span class="hljs-keyword">else</span> &#123;                        callback(pathname, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                            next(i + <span class="hljs-number">1</span>);                        &#125;);                    &#125;                &#125;);            &#125; <span class="hljs-keyword">else</span> &#123;                finish &amp;&amp; finish();            &#125;        &#125;(<span class="hljs-number">0</span>));    &#125;);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP第五章：与 HTTP 协作的 Web 服务器</title>
    <link href="/posts/15/index.html"/>
    <url>/posts/15/index.html</url>
    
    <content type="html"><![CDATA[<p>一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率</p><h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><ul><li>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点</li><li>在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站</li><li>在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。</li></ul><h2 id="通信数据转发程序-：-代理、-网关、-隧道"><a href="#通信数据转发程序-：-代理、-网关、-隧道" class="headerlink" title="通信数据转发程序 ： 代理、 网关、 隧道"></a>通信数据转发程序 ： 代理、 网关、 隧道</h2><p><strong>代理👇</strong></p><p>代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。</p><p><strong>网关👇</strong></p><p>网关是转发其他服务器通信数据的服务器， 接收从客户端发送来的请求时， 它就像自己拥有资源的源服务器一样对请求进行处理。 有时客户端可能都不会察觉， 自己的通信目标是一个网关</p><p><strong>隧道👇</strong></p><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转， 并保持双方通信连接的应用程序</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><img src="https://s1.ax1x.com/2020/08/23/d0H6Tx.png"></p><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。 代理不改变请求 URI， 会直接发送给前方持有资源的目标服务器（持有资源实体的服务器被称为源服务器）</p><p><img src="https://s1.ax1x.com/2020/08/23/d0HDX9.png"></p><p>在 HTTP 通信过程中， 可级联多台代理服务器。 请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。 转发时， 需要附加Via 首部字段以标记出经过的主机信息</p><p>使用代理服务器的理由：</p><ul><li>利用缓存技术减少网络带宽的流量</li><li>组织内部针对特定网站的访问控制</li><li>以获取访问日志为主要目的</li></ul><p>代理的多种使用方法（按两种基准分类）</p><ul><li>是否使用缓存</li><li>是否会修改报文</li></ul><p><strong>缓存代理</strong></p><p>代理转发响应时， 缓存代理（Caching Proxy） 会预先将资源的副本（缓存） 保存在代理服务器上。<br>当代理再次接收到对相同资源的请求时， 就可以不从源服务器那里获取资源， 而是将之前缓存的资源作为响应返回</p><p><strong>透明代理</strong></p><p>转发请求或响应时， 不对报文做任何加工的代理类型被称为透明代理 。反之， 对报文内容进行加工的代理被称为非透明代理</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><ul><li>网关能使通信线路上的服务器提供非 HTTP 协议服务</li><li>利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全</li></ul><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><ul><li>隧道的目的是确保客户端能与服务器进行安全的通信</li><li>隧道本身不会去解析 HTTP 请求</li><li>隧道会在通信双方断开连接时结束</li></ul><p><img src="https://s1.ax1x.com/2020/08/23/d0HsmR.png"></p><p>通过隧道的传输， 可以和远距离的服务器安全通信。 隧道本身是透明的， 客户端不用在意隧道的存在</p><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><ul><li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本</li><li>当代理转发从服务器返回的响应时， 代理服务器将会保存一份资源的副本</li><li>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源</li></ul><h3 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h3><p>即使存在缓存， 也会因为客户端的要求、 缓存的有效期等因素， 向源服务器确认资源的有效性。 若判断缓存失效， 缓存服务器将会再次从源服务器上获取“新”资源</p><h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><ul><li>缓存不仅可以存在于缓存服务器内， 还可以存在客户端浏览器中</li><li>把客户端缓存称为临时网络文件</li><li>当判定缓存过期后， 会向源服务器确认资源的有效性。 若判断浏览器缓存失效， 浏览器会再次请求新资源</li></ul>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
      <category>图解HTTp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图解HTTP</tag>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：Set</title>
    <link href="/posts/2/index.html"/>
    <url>/posts/2/index.html</url>
    
    <content type="html"><![CDATA[<p><code>Set</code>是一种新集合类型，为这门语言带来集合数据结构。<code>Set</code>在很多方面都像是加强的<code>Map</code>，这是因为它们的大多数 API 和行为都是共有的。</p><a id="more"></a><p>Set：用于存储任何类型的唯一值，无论是基本类型还是对象引用。</p><ul><li>只能保存值没有键名</li><li>严格类型检测如字符串数字不等于数值型数字</li><li>值是唯一的</li><li>遍历顺序是添加的顺序，方便保存回调函数</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>对象可以属性最终都会转为字符串</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;;<span class="hljs-built_in">console</span>.table(obj); <span class="hljs-comment">//&#123;1:&quot;object&quot;&#125;</span></code></pre><p>使用对象做为键名时，会将对象转为字符串后使用</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;;<span class="hljs-built_in">console</span>.table(obj);<span class="hljs-keyword">let</span> hd = &#123; [obj]: <span class="hljs-string">&quot;木易&quot;</span> &#125;;<span class="hljs-built_in">console</span>.table(hd);<span class="hljs-built_in">console</span>.log(hd[obj.toString()]);<span class="hljs-built_in">console</span>.log(hd[<span class="hljs-string">&quot;[object Object]&quot;</span>]);</code></pre><p>使用数组做初始数据</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;木易&#x27;</span>, <span class="hljs-string">&#x27;boreas&#x27;</span>]);<span class="hljs-built_in">console</span>.log(hd.values()); <span class="hljs-comment">//&#123;&quot;木易&quot;, &quot;boreas&quot;&#125;</span></code></pre><p>Set 中是严格类型约束的，下面的数值<code>1</code>与字符串<code>1</code>属于两个不同的值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();set.add(<span class="hljs-number">1</span>);set.add(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">//Set(2) &#123;1, &quot;1&quot;&#125;</span></code></pre><p>使用 <code>add</code> 添加元素，不允许重复添加<code>boreas</code>值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();hd.add(<span class="hljs-string">&#x27;object&#x27;</span>);hd.add(<span class="hljs-string">&#x27;boreas&#x27;</span>);hd.add(<span class="hljs-string">&#x27;boreas&#x27;</span>)<span class="hljs-built_in">console</span>.log(hd.values()); <span class="hljs-comment">//SetIterator &#123;&quot;object&quot;, &quot;boreas&quot;&#125;</span></code></pre><h3 id="获取数量"><a href="#获取数量" class="headerlink" title="获取数量"></a>获取数量</h3><p>获取元素数量</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;木易&#x27;</span>, <span class="hljs-string">&#x27;boreas&#x27;</span>]);<span class="hljs-built_in">console</span>.log(hd.size); <span class="hljs-comment">//2</span></code></pre><h3 id="元素检测"><a href="#元素检测" class="headerlink" title="元素检测"></a>元素检测</h3><p>检测元素是否存在</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();hd.add(<span class="hljs-string">&#x27;boreas&#x27;</span>);<span class="hljs-built_in">console</span>.log(hd.has(<span class="hljs-string">&#x27;boreas&#x27;</span>));<span class="hljs-comment">//true</span></code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用 <code>delete</code> 方法删除单个元素，返回值为<code>boolean</code>类型</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();hd.add(<span class="hljs-string">&quot;boreas&quot;</span>);hd.add(<span class="hljs-string">&quot;object&quot;</span>);<span class="hljs-built_in">console</span>.log(hd.delete(<span class="hljs-string">&quot;boreas&quot;</span>)); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(hd.values());<span class="hljs-built_in">console</span>.log(hd.has(<span class="hljs-string">&quot;boreas&quot;</span>)); <span class="hljs-comment">//false</span></code></pre><p>使用 <code>clear</code> 删除所有元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();hd.add(<span class="hljs-string">&#x27;boreas&#x27;</span>);hd.add(<span class="hljs-string">&#x27;object&#x27;</span>);hd.clear();<span class="hljs-built_in">console</span>.log(hd.values());</code></pre><h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>可以使用<code>点语法</code> 或 <code>Array.form</code> 静态方法将Set类型转为数组，这样就可以使用数组处理函数了</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>]);<span class="hljs-built_in">console</span>.log([...set]); <span class="hljs-comment">//[&quot;boreas&quot;, &quot;object&quot;]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(set)); <span class="hljs-comment">//[&quot;boreas&quot;, &quot;object&quot;]</span></code></pre><p>移除Set中大于5的数值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&quot;123456789&quot;</span>);hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...hd].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &lt; <span class="hljs-number">5</span>));<span class="hljs-built_in">console</span>.log(hd);</code></pre><h3 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h3><p>去除字符串重复</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([...new <span class="hljs-built_in">Set</span>(<span class="hljs-string">&quot;object&quot;</span>)].join(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">//object</span></code></pre><p>去除数组重复</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-built_in">console</span>.log(...new <span class="hljs-built_in">Set</span>(arr)); <span class="hljs-comment">// 1,2,4,5</span></code></pre><h3 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h3><p>使用 <code>keys()/values()/entries()</code> 都可以返回迭代对象，因为<code>set</code>类型只有值所以 <code>keys与values</code> 方法结果一致。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>]);<span class="hljs-built_in">console</span>.log(hd.values()); <span class="hljs-comment">//SetIterator &#123;&quot;boreas&quot;, &quot;object&quot;&#125;</span><span class="hljs-built_in">console</span>.log(hd.keys()); <span class="hljs-comment">//SetIterator &#123;&quot;boreas&quot;, &quot;object&quot;&#125;</span><span class="hljs-built_in">console</span>.log(hd.entries()); <span class="hljs-comment">//SetIterator &#123;&quot;boreas&quot; =&gt; &quot;boreas&quot;, &quot;object&quot; =&gt; &quot;object&quot;&#125;</span></code></pre><p>可以使用 <code>forEach</code> 遍历Set数据，默认使用 <code>values</code> 方法创建迭代器。</p><p>为了保持和遍历数组参数统一，函数中的value与key是一样的。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);<span class="hljs-comment">//使用forEach遍历</span>set.forEach(<span class="hljs-function">(<span class="hljs-params">item,key</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(item,key));</code></pre><p>也可以使用 <code>forof</code> 遍历Set数据，默认使用 <code>values</code> 方法创建迭代器</p><pre><code class="hljs javascript"><span class="hljs-comment">//使用for/of遍历</span><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> set) &#123;<span class="hljs-built_in">console</span>.log(iterator);&#125;</code></pre><h3 id="搜索实例"><a href="#搜索实例" class="headerlink" title="搜索实例"></a>搜索实例</h3><p>下面通过历史搜索的示例体验<code>Set</code> 类型</p><p><img src="https://s1.ax1x.com/2020/08/20/d3DdOg.gif"></p><blockquote><p>HTML</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><blockquote><p>CSS</p></blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">200px</span>;&#125;* &#123;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">input</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> <span class="hljs-number">#d63031</span>;    <span class="hljs-attribute">outline</span>: none;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">box-sizing</span>: border-box;&#125;<span class="hljs-selector-tag">ul</span> &#123;    <span class="hljs-attribute">list-style</span>: none;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">1px</span>;&#125;<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type(odd)</span> &#123;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#00b894</span>;&#125;</code></pre><blockquote><p>JS</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;    words: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),    <span class="hljs-keyword">set</span> <span class="hljs-title">keyword</span>(<span class="hljs-params">word</span>) &#123;        <span class="hljs-built_in">this</span>.words.add(word);    &#125;,    show() &#123;        <span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);        ul.innerHTML = <span class="hljs-string">&#x27;&#x27;</span>;        <span class="hljs-built_in">this</span>.words.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;            ul.innerHTML += (<span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span> + item + <span class="hljs-string">&#x27;&lt;/li&gt;&#x27;</span>);        &#125;)    &#125;&#125;<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    obj.keyword = <span class="hljs-built_in">this</span>.value;    obj.show();&#125;);</code></pre><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>获取两个集合中共同存在的元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;boreas&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>]);<span class="hljs-keyword">let</span> cms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;木易&#x27;</span>, <span class="hljs-string">&#x27;boreas&#x27;</span>]);<span class="hljs-keyword">let</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...hd].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> cms.has(item)));<span class="hljs-built_in">console</span>.log(newSet); <span class="hljs-comment">//&#123;&quot;boreas&quot;&#125;</span></code></pre><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>在集合a中出现但不在集合b中出现元素集合</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;boreas&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>]);<span class="hljs-keyword">let</span> cms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;木易&#x27;</span>, <span class="hljs-string">&#x27;boreas&#x27;</span>]);<span class="hljs-keyword">let</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...hd].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !cms.has(item)));<span class="hljs-built_in">console</span>.log(newSet); <span class="hljs-comment">//&#123;&quot;object&quot;&#125;</span></code></pre><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>将两个集合合并成一个新的集合，由于Set特性当然也不会产生重复元素。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;boreas&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>]);<span class="hljs-keyword">let</span> cms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;木易&#x27;</span>, <span class="hljs-string">&#x27;boreas&#x27;</span>]);<span class="hljs-keyword">let</span> newSet = [...hd, ...cms];<span class="hljs-built_in">console</span>.log(newSet);</code></pre><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet结构同样不会存储重复的值，它的成员必须只能是对象类型的值。</p><ul><li>垃圾回收不考虑WeakSet，即被WeakSet引用时引用计数器不加一，所以对象不被引用时不管WeakSet是否在使用都将删除</li><li>因为WeakSet 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach( )</code>遍历等操作</li><li>也是因为弱引用，WeakSet 结构没有keys( )，values( )，entries( )等方法和size属性</li><li>因为是弱引用所以当外部引用删除时，希望自动删除数据时使用 <code>WeakMap</code></li></ul><h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p>以下操作由于数据不是对象类型将产生错误</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>]); <span class="hljs-comment">//Invalid value used in weak set</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>(<span class="hljs-string">&quot;boreas&quot;</span>); <span class="hljs-comment">//Invalid value used in weak set</span></code></pre><p>WeakSet的值必须为对象类型</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([[<span class="hljs-string">&quot;boreas&quot;</span>], [<span class="hljs-string">&quot;object&quot;</span>]]);</code></pre><p>将DOM节点保存到<code>WeakSet</code></p><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;button&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> Wset.add(item));</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>下面是WeakSet的常用指令</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;boreas&quot;</span>];<span class="hljs-comment">//添加操作</span>hd.add(arr);<span class="hljs-built_in">console</span>.log(hd.has(arr));<span class="hljs-comment">//删除操作</span>hd.delete(arr);<span class="hljs-comment">//检索判断</span><span class="hljs-built_in">console</span>.log(hd.has(arr));</code></pre><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>WeaSet保存的对象不会增加引用计数器，如果一个对象不被引用了会自动删除。</p><ul><li>下例中的数组被 <code>arr</code> 引用了，引用计数器+1</li><li>数据又添加到了 hd 的WeaSet中，引用计数还是1</li><li>当 <code>arr</code> 设置为null时，引用计数-1 此时对象引用为0</li><li>当垃圾回收时对象被删除，这时WakeSet也就没有记录了</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;boreas&quot;</span>];hd.add(arr);<span class="hljs-built_in">console</span>.log(hd.has(arr));arr = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//WeakSet &#123;Array(1)&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//WeakSet &#123;&#125;</span>&#125;, <span class="hljs-number">1000</span>);</code></pre><h3 id="案例操作"><a href="#案例操作" class="headerlink" title="案例操作"></a>案例操作</h3><p><img src="https://s1.ax1x.com/2020/08/20/d3D0mQ.gif"></p><blockquote><p>HTML</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>object.com <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>boreas.com <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>houdunwang.com <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><blockquote><p>CSS</p></blockquote><pre><code class="hljs css">* &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">list-style</span>: none;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#e67e22</span>;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: space-between;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;  <span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span>;&#125;<span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">text-decoration</span>: none;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#16a085</span>;  <span class="hljs-attribute">color</span>: white;  <span class="hljs-attribute">cursor</span>: pointer;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;&#125;<span class="hljs-selector-class">.remove</span> &#123;  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#eee</span>;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;&#125;<span class="hljs-selector-class">.remove</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;&#125;</code></pre><blockquote><p>JS</p></blockquote><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todos</span> </span>&#123;   <span class="hljs-keyword">constructor</span>() &#123;&#125;   run() &#123;     <span class="hljs-built_in">this</span>.items = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;ul&gt;li&quot;</span>);     <span class="hljs-built_in">this</span>.lists = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();     <span class="hljs-built_in">this</span>.record();     <span class="hljs-built_in">this</span>.addEvent();   &#125;   addEvent() &#123;     <span class="hljs-built_in">this</span>.items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;       item.querySelector(<span class="hljs-string">&quot;a&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;         <span class="hljs-comment">//检测WakeSet中是否存在Li元素</span>         <span class="hljs-keyword">const</span> parentElement = event.target.parentElement;         <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.lists.has(parentElement)) &#123;           alert(<span class="hljs-string">&quot;已经删除此TODO&quot;</span>);         &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">//删除后从记录的WakeSet中移除</span>           parentElement.classList.add(<span class="hljs-string">&quot;remove&quot;</span>);           <span class="hljs-built_in">this</span>.lists.delete(parentElement);         &#125;       &#125;);     &#125;);   &#125;   record() &#123;     <span class="hljs-built_in">this</span>.items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">this</span>.lists.add(item));   &#125; &#125; <span class="hljs-keyword">new</span> Todos().run();</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：Map</title>
    <link href="/posts/6/index.html"/>
    <url>/posts/6/index.html</url>
    
    <content type="html"><![CDATA[<p><code>Map</code>是一种新的集合类型，为这门语言带来了真正的键 / 值存储机制。<code>Map</code>的大多数特性都可以通过<code>Object</code>类型实现，但二者之间还是存在一些细微的差异</p><a id="more"></a><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是一组键值对的结构，用于解决以往不能用对象做为键的问题</p><ul><li>具有极快的查找速度</li><li>函数、对象、基本类型都可以作为键或值</li></ul><h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p>可以接受一个数组作为参数，该数组的成员是一个表示键值对的数组。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;木易&#x27;</span>],  [<span class="hljs-string">&#x27;boreas&#x27;</span>, <span class="hljs-string">&#x27;博客笔记&#x27;</span>]]);<span class="hljs-built_in">console</span>.log(m.get(<span class="hljs-string">&#x27;object&#x27;</span>)); <span class="hljs-comment">//木易</span></code></pre><p>使用<code>set</code> 方法添加元素，支持链式操作</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> obj = &#123;  name: <span class="hljs-string">&quot;木易&quot;</span>&#125;;map.set(obj, <span class="hljs-string">&quot;object.com&quot;</span>).set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;boreas&quot;</span>);<span class="hljs-built_in">console</span>.log(map.entries()); <span class="hljs-comment">//MapIterator &#123;&#123;…&#125; =&gt; &quot;object.com&quot;, &quot;name&quot; =&gt; &quot;boreas&quot;&#125;</span></code></pre><p>使用构造函数<code>new Map</code>创建的原理如下</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">const</span> arr = [[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]];arr.forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;  hd.set(key, value);&#125;);<span class="hljs-built_in">console</span>.log(hd);</code></pre><p>对于键是对象的<code>Map</code>， 键保存的是内存地址，值相同但内存地址不同的视为两个键。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>];<span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();hd.set(arr, <span class="hljs-string">&quot;object.com&quot;</span>);<span class="hljs-built_in">console</span>.log(hd.get(arr)); <span class="hljs-comment">//object.com</span><span class="hljs-built_in">console</span>.log(hd.get([<span class="hljs-string">&quot;木易&quot;</span>])); <span class="hljs-comment">//undefined</span></code></pre><h3 id="获取数量"><a href="#获取数量" class="headerlink" title="获取数量"></a>获取数量</h3><p>获取数据数量</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(map.size);</code></pre><h3 id="元素检测"><a href="#元素检测" class="headerlink" title="元素检测"></a>元素检测</h3><p>检测元素是否存在</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(map.has(obj1));</code></pre><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> obj = &#123;name: <span class="hljs-string">&#x27;木易&#x27;</span>&#125;map.set(obj, <span class="hljs-string">&#x27;object.com&#x27;</span>);<span class="hljs-built_in">console</span>.log(map.get(obj));</code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用 <code>delete()</code> 方法删除单个元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> obj = &#123;name: <span class="hljs-string">&#x27;木易&#x27;</span>&#125;map.set(obj, <span class="hljs-string">&#x27;object.com&#x27;</span>);<span class="hljs-built_in">console</span>.log(map.get(obj));map.delete(obj);<span class="hljs-built_in">console</span>.log(map.get(obj));</code></pre><p>使用<code>clear</code>方法清除Map所有元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> obj1 = &#123;name: <span class="hljs-string">&#x27;boreas.com&#x27;</span>&#125;<span class="hljs-keyword">let</span> obj2 = &#123;name: <span class="hljs-string">&#x27;object.com&#x27;</span>&#125;map.set(obj1, &#123;title: <span class="hljs-string">&#x27;内容管理系统&#x27;</span>&#125;);map.set(obj2, &#123;title: <span class="hljs-string">&#x27;木易&#x27;</span>&#125;);<span class="hljs-built_in">console</span>.log(map.size);<span class="hljs-built_in">console</span>.log(map.clear());<span class="hljs-built_in">console</span>.log(map.size);</code></pre><h3 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h3><p>使用 <code>keys()/values()/entries()</code> 都可以返回可遍历的迭代对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);<span class="hljs-built_in">console</span>.log(hd.keys()); <span class="hljs-comment">//MapIterator &#123;&quot;object&quot;, &quot;boreas&quot;&#125;</span><span class="hljs-built_in">console</span>.log(hd.values()); <span class="hljs-comment">//MapIterator &#123;&quot;木易&quot;, &quot;博客笔记&quot;&#125;</span><span class="hljs-built_in">console</span>.log(hd.entries()); <span class="hljs-comment">//MapIterator &#123;&quot;object&quot; =&gt; &quot;木易&quot;, &quot;boreas&quot; =&gt; &quot;博客笔记&quot;&#125;</span></code></pre><p>可以使用<code>keys/values</code> 函数遍历键与值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> hd.keys()) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> hd.values()) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;</code></pre><p>使用<code>for/of</code>遍历操作，直播遍历Map 等同于使用<code>entries()</code> 函数</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> hd) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=&gt;<span class="hljs-subst">$&#123;value&#125;</span>`</span>);&#125;</code></pre><p>使用<code>forEach</code>遍历操作</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);hd.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=&gt;<span class="hljs-subst">$&#123;value&#125;</span>`</span>);&#125;);</code></pre><h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>可以使用<code>展开语法</code> 或 <code>Array.form</code> 静态方法将Set类型转为数组，这样就可以使用数组处理函数了</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);<span class="hljs-built_in">console</span>.log(...hd); <span class="hljs-comment">//(2) [&quot;object&quot;, &quot;木易&quot;] (2) [&quot;boreas&quot;, &quot;博客笔记&quot;]</span><span class="hljs-built_in">console</span>.log(...hd.entries()); <span class="hljs-comment">//(2) [&quot;object&quot;, &quot;木易&quot;] (2) [&quot;boreas&quot;, &quot;博客笔记&quot;]</span><span class="hljs-built_in">console</span>.log(...hd.values()); <span class="hljs-comment">//木易 博客笔记</span><span class="hljs-built_in">console</span>.log(...hd.keys()); <span class="hljs-comment">//object boreas</span></code></pre><p>检索包含<code>木易</code>的值组成新Map</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>], [<span class="hljs-string">&quot;boreas&quot;</span>, <span class="hljs-string">&quot;博客笔记&quot;</span>]]);<span class="hljs-keyword">let</span> newArr = [...hd].filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">return</span> item[<span class="hljs-number">1</span>].includes(<span class="hljs-string">&quot;木易&quot;</span>);&#125;);hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(newArr);<span class="hljs-built_in">console</span>.log(...hd.keys());</code></pre><h3 id="节点集合"><a href="#节点集合" class="headerlink" title="节点集合"></a>节点集合</h3><p>map的key可以为任意类型，下面使用DOM节点做为键来记录数据。</p><blockquote><p>HTML</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;木易&quot;</span>&gt;</span>object<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;博客笔记&quot;</span>&gt;</span>boreas<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>);divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> &#123;  divMap.set(div, &#123;    content: div.getAttribute(<span class="hljs-string">&quot;desc&quot;</span>)  &#125;);&#125;);divMap.forEach(<span class="hljs-function">(<span class="hljs-params">config, elem</span>) =&gt;</span> &#123;  elem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    alert(divMap.get(<span class="hljs-built_in">this</span>).content);  &#125;);&#125;);</code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><p>当不接受协议时无法提交表单，并根据自定义信息提示用户。</p><blockquote><p>HTML</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return post()&quot;</span>&gt;</span>    接受协议:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;agreement&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;请接受接受协议&quot;</span> /&gt;</span>    我是学生:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;网站只对学生开放&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">let</span> inputs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;[message]&quot;</span>);  <span class="hljs-comment">//使用set设置数据</span>  inputs.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>    map.set(item, &#123;      message: item.getAttribute(<span class="hljs-string">&quot;message&quot;</span>),      status: item.checked    &#125;)  );  <span class="hljs-comment">//遍历Map数据</span>  <span class="hljs-keyword">return</span> [...map].every(<span class="hljs-function">(<span class="hljs-params">[item, config]</span>) =&gt;</span> &#123;    config.status || alert(config.message);    <span class="hljs-keyword">return</span> config.status;  &#125;);&#125;</code></pre><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><strong>WeakMap</strong> 对象是一组键/值对的集</p><ul><li><p>键名必须是对象</p></li><li><p>WeaMap对键名是弱引用的，键值是正常引用</p></li><li><p>垃圾回收不考虑WeaMap的键名，不会改变引用计数器，键在其他地方不被引用时即删除</p></li><li><p>因为WeakMap 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach( )</code>遍历等操作</p></li><li><p>也是因为弱引用，WeaMap 结构没有keys( )，values( )，entries( )等方法和 size 属性</p></li><li><p>当键的外部引用删除时，希望自动删除数据时使用 <code>WeakMap</code></p></li></ul><h3 id="声明定义-1"><a href="#声明定义-1" class="headerlink" title="声明定义"></a>声明定义</h3><p>以下操作由于键不是对象类型将产生错误</p><pre><code class="hljs text">new WeakSet(&quot;boreas&quot;); //TypeError: Invalid value used in weak set</code></pre><p>将DOM节点保存到<code>WeakSet</code></p><blockquote><p>HTML</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>object<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>boreas<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>(); <span class="hljs-built_in">document</span>   .querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>)   .forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> hd.set(item, item.innerHTML)); <span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//WeakMap &#123;div =&gt; &quot;boreas&quot;, div =&gt; &quot;object&quot;&#125;</span></code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>下面是WeakSet的常用指令</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;boreas&quot;</span>];<span class="hljs-comment">//添加操作</span>hd.set(arr, <span class="hljs-string">&quot;object&quot;</span>);<span class="hljs-built_in">console</span>.log(hd.has(arr)); <span class="hljs-comment">//true</span><span class="hljs-comment">//删除操作</span>hd.delete(arr);<span class="hljs-comment">//检索判断</span><span class="hljs-built_in">console</span>.log(hd.has(arr)); <span class="hljs-comment">//false</span></code></pre><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>WakeMap的键名对象不会增加引用计数器，如果一个对象不被引用了会自动删除。</p><ul><li>下例当<code>hd</code>删除时内存即清除，因为WeakMap是弱引用不会产生引用计数</li><li>当垃圾回收时因为对象被删除，这时WakeMap也就没有记录了</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<span class="hljs-keyword">let</span> hd = &#123;&#125;;map.set(hd, <span class="hljs-string">&quot;boreas&quot;</span>);hd = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(map);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(map);&#125;, <span class="hljs-number">1000</span>);</code></pre><h3 id="选课案例"><a href="#选课案例" class="headerlink" title="选课案例"></a>选课案例</h3><p><img src="https://s1.ax1x.com/2020/08/21/dNsfSJ.gif"></p><blockquote><p>HTML</p></blockquote><p>​    </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>php<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>js<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>木易博客<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span>共选了0门课<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lists&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>CSS</p></blockquote><p>​    </p><pre><code class="hljs css">* &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">box-sizing</span>: border-box;&#125;<span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#ddd</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:last-of-type</span> &#123;  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">2px</span>;&#125;<span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">list-style</span>: none;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#e67e22</span>;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: space-between;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;  <span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span>;&#125;<span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">text-decoration</span>: none;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#16a085</span>;  <span class="hljs-attribute">color</span>: white;  <span class="hljs-attribute">cursor</span>: pointer;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;&#125;<span class="hljs-selector-class">.remove</span> &#123;  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#eee</span>;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;&#125;<span class="hljs-selector-class">.remove</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;&#125;<span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">span</span> &#123;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#16a085</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">color</span>: white;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;&#125;</code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lesson</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;      <span class="hljs-built_in">this</span>.lis = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;ul&gt;li&quot;</span>);      <span class="hljs-built_in">this</span>.countELem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;count&quot;</span>);      <span class="hljs-built_in">this</span>.listElem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;lists&quot;</span>);      <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();    &#125;    run() &#123;      <span class="hljs-built_in">this</span>.lis.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        item.querySelector(<span class="hljs-string">&quot;a&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;          <span class="hljs-keyword">const</span> elem = event.target;          <span class="hljs-keyword">const</span> state = elem.getAttribute(<span class="hljs-string">&quot;select&quot;</span>);          <span class="hljs-keyword">if</span> (state) &#123;            elem.removeAttribute(<span class="hljs-string">&quot;select&quot;</span>);            <span class="hljs-built_in">this</span>.map.delete(elem.parentElement);            elem.innerHTML = <span class="hljs-string">&quot;+&quot;</span>;            elem.style.backgroundColor = <span class="hljs-string">&quot;green&quot;</span>;          &#125; <span class="hljs-keyword">else</span> &#123;            elem.setAttribute(<span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-literal">true</span>);            <span class="hljs-built_in">this</span>.map.set(elem.parentElement, <span class="hljs-literal">true</span>);            elem.innerHTML = <span class="hljs-string">&quot;-&quot;</span>;            elem.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;          &#125;          <span class="hljs-built_in">this</span>.render();        &#125;);      &#125;);    &#125;    count() &#123;      <span class="hljs-keyword">return</span> [...this.lis].reduce(<span class="hljs-function">(<span class="hljs-params">count, item</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> (count += <span class="hljs-built_in">this</span>.map.has(item) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);      &#125;, <span class="hljs-number">0</span>);    &#125;    lists() &#123;      <span class="hljs-keyword">return</span> [...this.lis]        .filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.map.has(item);        &#125;)        .map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;span&gt;<span class="hljs-subst">$&#123;item.querySelector(<span class="hljs-string">&quot;span&quot;</span>).innerHTML&#125;</span>&lt;/span&gt;`</span>;        &#125;);    &#125;    render() &#123;      <span class="hljs-built_in">this</span>.countELem.innerHTML = <span class="hljs-string">`共选了<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.count()&#125;</span>课`</span>;      <span class="hljs-built_in">this</span>.listElem.innerHTML = <span class="hljs-built_in">this</span>.lists().join(<span class="hljs-string">&quot;&quot;</span>);    &#125;  &#125;  <span class="hljs-keyword">new</span> Lesson().run();</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Map</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP第四章：返回结果的HTTP状态码</title>
    <link href="/posts/16/index.html"/>
    <url>/posts/16/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h2><ul><li>状态码的职责是当客户端向服务器端发送请求时， 描述返回的请求结果</li><li>通过状态码 用户可以知道服务器端是正常处理了请求， 还是出现了错误</li></ul><p><strong>状态码类别👇</strong></p><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><blockquote><p>注：数字中的第一位指定了响应类别， 后两位无分类</p></blockquote><h2 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h2><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p><strong>表示从客户端发来的请求在服务器端被正常处理了</strong></p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><ul><li>该状态码代表服务器接收的请求已成功处理， 但在返回的响应报文中不含实体的主体部分</li><li>一般在只需要从客户端往服务器发送信息， 而对客户端不需要发送新信息内容情况下使用</li></ul><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的GET 请求</p><p><img src="https://s1.ax1x.com/2020/08/20/dJQhpd.png"></p><h2 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h2><p><strong>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI</p><p><img src="https://s1.ax1x.com/2020/08/20/dJ8B4O.png"></p><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问</p><p><img src="https://s1.ax1x.com/2020/08/20/dJGVIK.png"></p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET方法定向获取请求的资源</p><p><img src="https://s1.ax1x.com/2020/08/20/dJ80UK.png"></p><blockquote><p>当 301、 302、 303 响应状态码返回时， 几乎所有的浏览器都会把POST 改成 GET， 并删除请求报文内的主体， 之后请求会自动再次发送</p></blockquote><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p><strong>4XX 的响应结果表明客户端是发生错误的原因所在</strong></p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误。 当错误发生时， 需修改请求的内容后再次发送请求</p><p><img src="https://s1.ax1x.com/2020/08/20/dJ8aHx.png"></p><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><ul><li>该状态码表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>若之前已进行过 1 次请求， 则表示用户认证失败</li></ul><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了</p><p><img src="https://s1.ax1x.com/2020/08/20/dJ8wE6.png"></p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到请求的资源</p><p><img src="https://s1.ax1x.com/2020/08/20/dJGlqI.png"></p><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p><strong>5XX 的响应结果表明服务器本身发生错误</strong></p><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表明服务器端在执行请求时发生了错误。 也有可能是 Web应用存在的 bug 或某些临时的故障</p><p><img src="https://s1.ax1x.com/2020/08/20/dJGdMj.png"></p><h3 id="503-Service-Unavailable-1"><a href="#503-Service-Unavailable-1" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求</p><p><img src="https://s1.ax1x.com/2020/08/20/dJGUzQ.png"></p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
      <category>图解HTTp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图解HTTP</tag>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：Symbol</title>
    <link href="/posts/3/index.html"/>
    <url>/posts/3/index.html</url>
    
    <content type="html"><![CDATA[<p><code>Symbol</code>（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><a id="more"></a><p>Symbol用于防止属性名冲突而产生的，比如向第三方对象中添加属性时。</p><p>Symbol 的值是唯一的，独一无二的不会重复的</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>();<span class="hljs-keyword">let</span> edu = <span class="hljs-built_in">Symbol</span>();<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//symbol</span><span class="hljs-built_in">console</span>.log(hd == edu); <span class="hljs-comment">//false</span></code></pre><p>Symbol 不可以添加属性</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>();hd.name = <span class="hljs-string">&quot;木易&quot;</span>;<span class="hljs-built_in">console</span>.log(hd.name);</code></pre><h3 id="描述参数"><a href="#描述参数" class="headerlink" title="描述参数"></a>描述参数</h3><p>可传入字符串用于描述Symbol，方便在控制台分辨Symbol</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;is name&quot;</span>);<span class="hljs-keyword">let</span> edu = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;这是一个测试&quot;</span>);<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//Symbol(is name)</span><span class="hljs-built_in">console</span>.log(edu.toString()); <span class="hljs-comment">//Symbol(这是一个测试)</span></code></pre><p>传入相同参数Symbol也是独立唯一的，因为参数只是描述而已，但使用 <code>Symbol.for</code>则不会</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-keyword">let</span> edu = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-built_in">console</span>.log(hd == edu); <span class="hljs-comment">//false</span></code></pre><p>使用<code>description</code>可以获取传入的描述参数</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-built_in">console</span>.log(hd.description); <span class="hljs-comment">//木易</span></code></pre><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h3><p>根据描述获取Symbol，如果不存在则新建一个Symbol</p><ul><li>使用Symbol.for会在系统中将Symbol登记</li><li>使用Symbol则不会登记</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-keyword">let</span> edu = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-built_in">console</span>.log(hd == edu); <span class="hljs-comment">//true</span></code></pre><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h3><p><code>Symbol.keyFor</code> 根据使用<code>Symbol.for</code>登记的Symbol返回描述，如果找不到返回undefined 。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(hd)); <span class="hljs-comment">//木易</span><span class="hljs-keyword">let</span> edu = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;houdunren&quot;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(edu)); <span class="hljs-comment">//undefined</span></code></pre><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><p>Symbol 是独一无二的所以可以保证对象属性的唯一。</p><ul><li>Symbol 声明和访问使用 <code>[]</code>（变量）形式操作</li><li>也不能使用 <code>.</code> 语法因为 <code>.</code>语法是操作字符串属性的。</li></ul><p>下面写法是错误的，会将<code>symbol</code> 当成字符串<code>symbol</code>处理</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-keyword">let</span> obj = &#123;  symbol: <span class="hljs-string">&quot;boreas&quot;</span>&#125;;<span class="hljs-built_in">console</span>.log(obj);</code></pre><p>正确写法是以<code>[]</code> 变量形式声明和访问</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-keyword">let</span> obj = &#123;  [symbol]: <span class="hljs-string">&quot;object&quot;</span>&#125;;<span class="hljs-built_in">console</span>.log(obj[symbol]); <span class="hljs-comment">//object</span></code></pre><h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><h3 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h3><p>使用<code>Symbol</code>可以解决在保存数据时由于名称相同造成的耦合覆盖问题。</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span> </span>&#123;  <span class="hljs-keyword">static</span> data = &#123;&#125;;  <span class="hljs-keyword">static</span> set(name, value) &#123;    <span class="hljs-built_in">this</span>.data[name] = value;  &#125;  <span class="hljs-keyword">static</span> get(name) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data[name];  &#125;&#125;<span class="hljs-keyword">let</span> user = &#123;  name: <span class="hljs-string">&quot;木易&quot;</span>,  key: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;缓存&quot;</span>)&#125;;<span class="hljs-keyword">let</span> cart = &#123;  name: <span class="hljs-string">&quot;购物车&quot;</span>,  key: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;购物车&quot;</span>)&#125;;Cache.set(user.key, user);Cache.set(cart.key, cart);<span class="hljs-built_in">console</span>.log(Cache.get(user.key));</code></pre><h3 id="遍历属性"><a href="#遍历属性" class="headerlink" title="遍历属性"></a>遍历属性</h3><p>Symbol 不能使用 <code>for/in</code>、<code>for/of</code> 遍历操作</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;木易&quot;</span>);<span class="hljs-keyword">let</span> obj = &#123;  name: <span class="hljs-string">&quot;boreas&quot;</span>,  [symbol]: <span class="hljs-string">&quot;object&quot;</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">//name</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">//name</span>&#125;</code></pre><p>可以使用 <code>Object.getOwnPropertySymbols</code> 获取所有<code>Symbol</code>属性</p><pre><code class="hljs javascript">...<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj)) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;</code></pre><p>也可以使用 <code>Reflect.ownKeys(obj)</code> 获取所有属性包括<code>Symbol</code></p><pre><code class="hljs javascript">...<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;...</code></pre><p>如果对象属性不想被遍历，可以使用<code>Symbol</code>保护</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> site = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;网站名称&quot;</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(name) &#123;    <span class="hljs-built_in">this</span>[site] = <span class="hljs-string">&quot;木易&quot;</span>;    <span class="hljs-built_in">this</span>.name = name;  &#125;  getName() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>[site]&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>;  &#125;&#125;<span class="hljs-keyword">const</span> hd = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;XJ大叔&quot;</span>);<span class="hljs-built_in">console</span>.log(hd.getName());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> hd) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Symbol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP第三章：HTTP报文内的HTTP信息</title>
    <link href="/posts/13/index.html"/>
    <url>/posts/13/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><ol><li>用于 HTTP 协议交互的信息被称为 HTTP 报文</li><li>请求端（客户端） 的HTTP 报文叫做请求报文</li><li>响应端（服务器端） 的叫做响应报文</li><li>HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本</li><li>HTTP 报文分为报文首部和报文主体两块</li></ol><p><img src="https://s1.ax1x.com/2020/08/17/dn9I9f.png"></p><h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p><strong>请求报文（ 上） 和响应报文（ 下） 的结构</strong></p><p><img src="https://s1.ax1x.com/2020/08/17/dn9TgS.png"></p><p><strong>请求报文（ 上） 和响应报文（ 下） 的实例</strong></p><p><img src="https://s1.ax1x.com/2020/08/17/dn9buQ.png"></p><ul><li>请求行：包含用于请求的方法， 请求 URI 和 HTTP 版本</li><li>状态行：包含表明响应结果的状态码， 原因短语和 HTTP 版本</li><li>首部字段：包含表示请求和响应的各种条件和属性的各类首部<ul><li>通用首部</li><li>请求首部</li><li>响应首部</li><li>实体首部</li></ul></li><li>其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）</li></ul><h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP 在传输数据时可以按照数据原貌直接传输， 也可以在传输过程中通过编码提升传输速率</p><p>编码的操作需要计算机来完成， 因此会消耗更多的 CPU 等资源</p><h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul><li><p>报文</p><p>是 HTTP 通信中的基本单位， 由 8 位组字节流（octet sequence，其中 octet 为 8 个比特） 组成， 通过 HTTP 通信传输</p></li><li><p>实体</p><p>作为请求或响应的有效载荷数据（补充项） 被传输， 其内容由实体首部和实体主体组成</p></li></ul><h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>内容编码指明应用在实体内容上的编码格式， 并保持实体信息原样压缩。 内容编码后的实体由客户端接收并负责解码</p><p><img src="https://s1.ax1x.com/2020/08/17/dn9o38.png"></p><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>把实体主体分块的功能称为分块传输编码</p><p><img src="https://s1.ax1x.com/2020/08/17/dn97jg.png"></p><h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><ol><li>邮件使用了 MIME 机制 可以处理文本、 图片、 视频等多个不同类型的数据</li><li>MIME 扩展中使用一种称为<strong>多部分对象集合</strong>（Multipart） 的方法， 来容纳多份不同类型的数据</li></ol><p><strong>多部分对象集合包含的对象👇</strong></p><ul><li><p>multipart/form-data</p><p>在 Web 表单文件上传时使用</p></li><li><p>multipart/byteranges</p><p>状态码 206 响应报文包含了多个范围的内容时使用</p></li></ul><p><strong>在 HTTP 报文中使用多部分对象集合时， 需要在首部字段里加上Content-type</strong></p><h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>指定范围发送的请求叫做范围请求</p><p><img src="https://s1.ax1x.com/2020/08/17/dn9LHs.png"></p><p>执行范围请求时， 会用到首部字段 Range 来指定资源的 byte 范围</p><ul><li><p>5001~10 000 字节</p><pre><code class="hljs angelscript">Range: bytes=<span class="hljs-number">5001</span><span class="hljs-number">-10000</span></code></pre></li><li><p>从 5001 字节之后全部的</p><pre><code class="hljs routeros">Range: <span class="hljs-attribute">bytes</span>=5001-</code></pre></li><li><p>从一开始到 3000 字节和 5000~7000 字节的多重范围</p><pre><code class="hljs angelscript">Range: bytes=<span class="hljs-number">-3000</span>, <span class="hljs-number">5000</span><span class="hljs-number">-7000</span></code></pre></li></ul><p>针对范围请求， 响应会返回状态码为 206 Partial Content 的响应报文</p><p>对于多重范围的范围请求， 响应会在首部字段 ContentType 标明 multipart/byteranges 后返回响应报文</p><h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉， 然后提供给客户端最为适合的资源。 内容协商会以响应资源的语言、 字符集、 编码方式等作为判断的基准</p><p><img src="https://s1.ax1x.com/2020/08/17/dn9qBj.png"></p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
      <category>图解HTTp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图解HTTP</tag>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP第二章：简单的HTTP协议</title>
    <link href="/posts/14/index.html"/>
    <url>/posts/14/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-协议用于客户端和服务器端之间的通信"><a href="#HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP 协议用于客户端和服务器端之间的通信"></a>HTTP 协议用于客户端和服务器端之间的通信</h2><p>请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端</p><p> HTTP 协议能够明确区分哪端是客户端， 哪端是服务器端</p><p><img src="https://s1.ax1x.com/2020/08/19/d1zwQ0.png"></p><h2 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h2><p><strong>HTTP 协议规定， 请求从客户端发出， 最后服务器端响应该请求并返回</strong></p><p>请求报文内容</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.htm</span> HTTP/1.1<span class="hljs-attribute">Host</span>: hackr.jp</code></pre><ul><li>开头的GET表示请求访问服务器的类型， 称为方法</li><li>随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI</li><li>最后的 HTTP/1.1， 即 HTTP 的版本号</li><li>请求报文是由请求方法、 请求 URI、 协议版本、 可选的请求首部字段和内容实体构成的</li></ul><p>响应报文内容</p><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<span class="hljs-attribute">Date</span>: Tue, <span class="hljs-number">10</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">06</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span> GMT<span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">362</span><span class="hljs-attribute">Content</span>-Type: text/html</code></pre><ul><li>HTTP/1.1 表示服务器对应的 HTTP 版本</li><li>200 OK 表示请求的处理结果的状态码和原因短语</li><li>Date显示了创建响应的日期时间</li><li>之后的内容称为资源实体的主体</li><li>响应报文基本上由协议版本、 状态码用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成</li></ul><h2 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h2><ul><li>HTTP 是一种不保存状态， 即无状态（stateless） 协议</li><li>为了实现保持状态功能，HTTP协议有了Cookie</li></ul><h2 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h2><p><img src="https://s1.ax1x.com/2020/08/20/dJQkQI.png"></p><ul><li><p>HTTP 协议使用 URI 定位互联网上的资源</p></li><li><p>如不是访问特定资源而是对服务器本身发起请求， 可以用一个 * 来代替请求 URI</p><pre><code class="hljs text">OPTIONS * HTTP/1.1</code></pre></li></ul><h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><h3 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h3><p><strong>GET 方法用来请求访问已被 URI 识别的资源</strong></p><table><thead><tr><th>请求</th><th>GET /index.html HTTP/1.1<br />Host: <a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>返回 index.html 的页面资源</td></tr></tbody></table><h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p><strong>POST 方法用来传输实体的主体。</strong></p><table><thead><tr><th>请求</th><th>POST /submit.cgi HTTP/1.1<br />Host: <a href="http://www.hackr.jp/">www.hackr.jp</a><br />Content-Length: 1560（1560字节的数据）</th></tr></thead><tbody><tr><td>响应</td><td>返回 submit.cgi 接收数据的处理结果</td></tr></tbody></table><h3 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h3><ul><li>PUT 方法用来传输文件</li><li>PUT方法存在安全性问题， 因此一般的 Web 网站不使用该方法</li></ul><table><thead><tr><th>请求</th><th>PUT /example.html HTTP/1.1<br/>Host: <a href="http://www.hackr.jp/">www.hackr.jp</a><br/>Content-Type: text/html<br/>Content-Length: 1560（1560 字节的数据）</th></tr></thead><tbody><tr><td>响应</td><td>响应返回状态码 204 No Content（比如 ： 该 html 已存在于服务器上）</td></tr></tbody></table><h3 id="HEAD：获得报文首部"><a href="#HEAD：获得报文首部" class="headerlink" title="HEAD：获得报文首部"></a>HEAD：获得报文首部</h3><p><strong>HEAD 方法和 GET 方法一样， 只是不返回报文主体部分。 用于确认URI 的有效性及资源更新的日期时间等</strong></p><table><thead><tr><th>请求</th><th>HEAD /index.html HTTP/1.1<br/>Host: <a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>返回index.html有关的响应首部</td></tr></tbody></table><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p><strong>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法</strong></p><table><thead><tr><th>请求</th><th>OPTIONS * HTTP/1.1<br/>Host: <a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>HTTP/1.1 200 OK<br/>Allow: GET, POST, HEAD, OPTIONS<br/>（返回服务器支持的方法）</td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/08/20/dJQmTS.png"></p><h2 id="使用方法下达命令"><a href="#使用方法下达命令" class="headerlink" title="使用方法下达命令"></a>使用方法下达命令</h2><p>向请求 URI 指定的资源发送请求报文时， 采用称为方法的命令。方法中有 GET、 POST 和 HEAD 等</p><p><img src="https://s1.ax1x.com/2020/08/20/dJQKYQ.png"></p><p><strong>HTTP/1.0 和 HTTP/1.1 支持的方法（方法名区分大小写， 注意要用大写字母）👇</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>支持的 HTTP 协议版本</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>1.0  1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>1.0  1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0  1.1</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>1.0  1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0  1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.0</td></tr><tr><td>UNLINE</td><td>断开连接关系</td><td>1.0</td></tr></tbody></table><h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><ul><li>持久连接的特点是， 只要任意一端没有明确提出断开连接， 则保持 TCP 连接状态</li><li>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销， 减轻了服务器端的负载</li><li>在 HTTP/1.1 中， 所有的连接默认都是持久连接</li></ul><p><img src="https://s1.ax1x.com/2020/08/20/dJQMWj.png"></p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p> 从前发送请求后需等待并收到响应， 才能发送下一个请求，管线化技术可以不用等待响应亦可直接发送下一个请求，这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应</p><p><img src="https://s1.ax1x.com/2020/08/20/dJQuFg.png"></p><h2 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h2><ul><li><p>Cookie技术通过在请求喝响应报文中写入Cookie信息来控制客户端的状态</p></li><li><p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。</p></li><li><p>当下一次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去</p></li></ul><p>请求报文（ 没有 Cookie 信息的状态）</p><pre><code class="hljs text">GET /reader/ HTTP/1.1Host: hackr.jp*首部字段内没有Cookie的相关信息</code></pre><p>响应报文（ 服务器端生成 Cookie 信息）</p><pre><code class="hljs text">HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞Content-Type: text/plain; charset=UTF-8</code></pre><p>请求报文（ 自动发送保存着的 Cookie 信息）</p><pre><code class="hljs text">GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1342077140226724</code></pre>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
      <category>图解HTTp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图解HTTP</tag>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP第一章：了解 Web 及网络基础</title>
    <link href="/posts/12/index.html"/>
    <url>/posts/12/index.html</url>
    
    <content type="html"><![CDATA[<h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h2><ol><li>通常使用的网络（包括互联网） 是在 TCP/IP 协议族的基础上运作的。 而 HTTP 属于它内部的一个子集</li></ol><p><img src="https://s1.ax1x.com/2020/08/17/dmO0bV.png"></p><h3 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h3><ol start="2"><li>TCP/IP协议族分为4层：应用层，传输层，网络层。数据链路层<ul><li>应用层决定了向用户提供应用服务时通信的活动</li><li>传输层对上层应用层， 提供处于网络连接中的两台计算机之间的数据传输</li><li>网络层用来处理在网络上流动的数据包。 数据包是网络传输的最小数据单位</li><li>链路层（或数据链路层，网络接口层）：用来处理连接网络的硬件部分，包括操作系统，硬件和设备驱动</li></ul></li></ol><h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h3><p>利用 <code>TCP/IP</code> 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走</p><p><img src="https://s1.ax1x.com/2020/08/17/dmOrUU.png"></p><p>把数据信息包装起来的做法称为封装</p><h2 id="与-HTTP-关系密切的协议-IP、-TCP-和DNS"><a href="#与-HTTP-关系密切的协议-IP、-TCP-和DNS" class="headerlink" title="与 HTTP 关系密切的协议 : IP、 TCP 和DNS"></a>与 HTTP 关系密切的协议 : IP、 TCP 和DNS</h2><h3 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h3><ol><li>负责传输的IP协议：属于网络层，是一种协议的名称</li><li>IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址</li><li>ARP 是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址</li></ol><p><img src="https://s1.ax1x.com/2020/08/17/dmOs5F.png"></p><h3 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h3><ol><li>按层次分， TCP 位于传输层， 提供可靠的字节流服务</li><li>TCP 协议采用了三次握手（three-way handshaking） 策略</li></ol><p><img src="https://s1.ax1x.com/2020/08/17/dmOwD0.png"></p><ul><li>发送端首先发送一个带 SYN 标志的数据包给对方。 </li><li>接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 </li><li>最后， 发送端再回传一个带 ACK 标志的数据包， 代表“握手”结束</li></ul><h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><ol><li>DNS（Domain Name System） 服务是和 HTTP 协议一样位于应用层的协议。 它提供域名到 IP 地址之间的解析服务</li><li>DNS 协议提供通过域名查找 IP 地址， 或逆向从 IP 地址反查域名的服务</li></ol><p><img src="https://s1.ax1x.com/2020/08/17/dmODET.png"></p><h2 id="各种协议与-HTTP-协议的关系"><a href="#各种协议与-HTTP-协议的关系" class="headerlink" title="各种协议与 HTTP 协议的关系"></a>各种协议与 HTTP 协议的关系</h2><p><img src="https://s1.ax1x.com/2020/08/17/dmOc8J.png"></p><h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><ol><li>URI 就是由某个协议方案表示的资源的定位标识符。 协议方案是指访问资源所使用的协议类型名称</li><li>URI 用字符串标识某一互联网资源， 而 URL表示资源的地点   URL是 URI 的子集</li></ol><h3 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h3><ol><li>相对 URL， 是指从浏览器中基本 URI 处指定的 URL</li></ol><p><strong>URI格式</strong></p><p><img src="https://s1.ax1x.com/2020/08/17/dmO6C4.png"></p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
      <category>图解HTTp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图解HTTP</tag>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：Array</title>
    <link href="/posts/4/index.html"/>
    <url>/posts/4/index.html</url>
    
    <content type="html"><![CDATA[<p><code>Array</code>是 ECMAScript 中最常用的类型。ECMAScript 数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。</p><a id="more"></a><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>数组是多个变量值的集合，数组是<code>Array</code> 对象的实例</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>使用对象方式创建数组</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>)); <span class="hljs-comment">//[1, &quot;木易&quot;, &quot;object&quot;]</span></code></pre><p>使用字面量创建是推荐的简单作法</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>];</code></pre><p>多维数组定义</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [[<span class="hljs-string">&quot;object&quot;</span>], [<span class="hljs-string">&quot;title&quot;</span>]];<span class="hljs-built_in">console</span>.log(array[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);</code></pre><p>数组是引用类型可以使用<code>const</code>声明并修改它的值</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>];array.push(<span class="hljs-string">&quot;Boreas&quot;</span>);<span class="hljs-built_in">console</span>.log(array);</code></pre><p>使用原型的 <code>length</code>属性可以获取数组元素数量</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(hd.length); <span class="hljs-comment">//2</span></code></pre><p>数组可以设置任何值，下面是使用索引添加数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = [<span class="hljs-string">&quot;木易&quot;</span>];hd[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;object&quot;</span>;</code></pre><p>下面直接设置 3 号数组，会将 1/2 索引的数组定义为空值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = [<span class="hljs-string">&quot;木易&quot;</span>];hd[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-built_in">console</span>.log(hd.length); <span class="hljs-comment">//4</span></code></pre><p>声明多个空元素的数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(hd.length);<span class="hljs-built_in">console</span>.log(hd);</code></pre><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p>使用<code>Array.of</code> 与 <code>new Array</code> 不同是设置一个参数时不会创建空元素数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hd = <span class="hljs-built_in">Array</span>.of(<span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//[3]</span>hd = <span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//[1, 2, 3]</span></code></pre><h3 id="类型检测-类型检测"><a href="#类型检测-类型检测" class="headerlink" title="类型检测)类型检测"></a>类型检测)类型检测</h3><p>检测变量是否为数组类型</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([<span class="hljs-number">1</span>, <span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>])); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">9</span>)); <span class="hljs-comment">//false</span></code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>可以将数组转换为字符串也可以将其他类型转换为数组。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>大部分数据类型都可以使用<code>.toString()</code> 函数转换为字符串。</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].toString()); <span class="hljs-comment">// 1,2,3</span></code></pre><p>也可以使用函数 <code>String</code> 转换为字符串。</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));</code></pre><p>或使用<code>join</code>连接为字符串</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].join(<span class="hljs-string">&quot;-&quot;</span>)); <span class="hljs-comment">//1-2-3</span></code></pre><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>使用<code>Array.from</code>可将类数组转换为数组，类数组指包含 <code>length</code> 属性或可迭代的对象。</p><ul><li>第一个参数为要转换的数据，第二个参数为类似于<code>map</code> 函数的回调方法</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;木易&quot;</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(str)); <span class="hljs-comment">//[&quot;后&quot;, &quot;盾&quot;, &quot;人&quot;]</span></code></pre><p>为对象设置<code>length</code>属性后也可以转换为数组，但要下标为数值或数值字符串</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;木易&quot;</span>,  <span class="hljs-number">1</span>: <span class="hljs-number">18</span>,  length: <span class="hljs-number">2</span>,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(user)); <span class="hljs-comment">//[&quot;木易&quot;, 18]</span></code></pre><p>DOM 元素转换为数组后来使用数组函数，第二个参数类似于<code>map</code> 函数的方法，可对数组元素执行函数处理。</p><blockquote><p>html</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;木易&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;object&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> btns = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;button&quot;</span>);<span class="hljs-built_in">console</span>.log(btns); <span class="hljs-comment">//包含length属性</span><span class="hljs-built_in">Array</span>.from(btns, <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;  item.style.background = <span class="hljs-string">&quot;red&quot;</span>;&#125;);</code></pre><h3 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h3><p>使用展开语法将 <code>NodeList</code> 转换为数组操作</p><blockquote><p>css</p></blockquote><pre><code class="hljs css"><span class="hljs-selector-class">.hide</span> &#123;  <span class="hljs-attribute">display</span>: none;&#125;</code></pre><blockquote><p>html</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>object<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>);[...divs].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>&#123;  div.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&quot;hide&quot;</span>);  &#125;);&#125;);</code></pre><h2 id="展开语法-1"><a href="#展开语法-1" class="headerlink" title="展开语法"></a>展开语法</h2><h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><p>使用展开语法来合并数组相比 <code>concat</code> 要更简单，使用<code>...</code> 可将数组展开为多个值。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> b = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>, ...a];<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//[&quot;a&quot;, &quot;木易&quot;, 1, 2, 3]</span></code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>使用展示语法可以替代 <code>arguments</code> 来接收任意数量的参数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hd</span>(<span class="hljs-params">...args</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(args);&#125;hd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;木易&quot;</span>); <span class="hljs-comment">//[1, 2, 3, &quot;木易&quot;]</span></code></pre><p>也可以用于接收部分参数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hd</span>(<span class="hljs-params">site, ...args</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(site, args); <span class="hljs-comment">//木易 (3) [1, 2, 3]</span>&#125;hd(<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><h3 id="节点转换"><a href="#节点转换" class="headerlink" title="节点转换"></a>节点转换</h3><p>可以将 DOM 节点转为数组，下面例子不可以使用 filter 因为是节点列表</p><blockquote><p>html</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;木易&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;object&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> btns = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;button&quot;</span>);btns.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">//TypeError: btns.filter is not a function</span>&#125;);</code></pre><p>使用展开语法后就可以使用数据方法</p><blockquote><p>html</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>object<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>);[...divs].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>&#123;  div.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&quot;hide&quot;</span>);  &#125;);&#125;);</code></pre><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构</p><ul><li>建设使用 <code>var/let/const</code> 声明</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>下面是基本使用语法</p><pre><code class="hljs javascript"><span class="hljs-comment">//数组使用</span><span class="hljs-keyword">let</span> [name, url] = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;title.com&quot;</span>];<span class="hljs-built_in">console</span>.log(name);</code></pre><p>解构赋值数组</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hd</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];&#125;<span class="hljs-keyword">let</span> [a, b] = hd();<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//title</span></code></pre><p>剩余解构指用一个变量来接收剩余参数</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a, ...b] = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(b);</code></pre><p>如果变量已经初始化过，就要使用<code>()</code> 定义赋值表达式，严格模式会报错所以不建议使用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> web = <span class="hljs-string">&quot;木易&quot;</span>;[web, url] = [<span class="hljs-string">&quot;object.com&quot;</span>, <span class="hljs-string">&quot;title.com&quot;</span>];<span class="hljs-built_in">console</span>.log(web);</code></pre><p>字符串解构</p><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">const</span> [...a] = <span class="hljs-string">&quot;title.com&quot;</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//Array(13)</span></code></pre><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明。</p><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;[web, url] = [<span class="hljs-string">&quot;object.com&quot;</span>, <span class="hljs-string">&quot;title.com&quot;</span>];<span class="hljs-built_in">console</span>.log(web);</code></pre><h3 id="简洁定义"><a href="#简洁定义" class="headerlink" title="简洁定义"></a>简洁定义</h3><p>只赋值部分变量</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [, url] = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;title.com&quot;</span>];<span class="hljs-built_in">console</span>.log(url); <span class="hljs-comment">//title.com</span></code></pre><p>使用展开语法获取多个值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [name, ...arr] = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title.com&quot;</span>];<span class="hljs-built_in">console</span>.log(name, arr); <span class="hljs-comment">//木易 (2) [&quot;object&quot;, &quot;title.com&quot;]</span></code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>为变量设置默认值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [name, site = <span class="hljs-string">&quot;object&quot;</span>] = [<span class="hljs-string">&quot;木易&quot;</span>];<span class="hljs-built_in">console</span>.log(site); <span class="hljs-comment">//object</span></code></pre><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><p>数组参数的使用</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hd</span>(<span class="hljs-params">[a, b]</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(a, b);&#125;hd([<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>]);</code></pre><h2 id="管理元素"><a href="#管理元素" class="headerlink" title="管理元素"></a>管理元素</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用从 0 开始的索引来改变数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;木易教程&quot;</span>;<span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[1, &quot;木易教程&quot;, &quot;object&quot;]</span></code></pre><p>向数组追回元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];arr[arr.length] = <span class="hljs-string">&quot;title.com&quot;</span>;<span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[1, &quot;木易&quot;, &quot;object&quot;, &quot;title.com&quot;]</span></code></pre><h3 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h3><p>使用展示语法批量添加元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">let</span> hd = [<span class="hljs-string">&quot;title&quot;</span>];hd.push(...arr);<span class="hljs-built_in">console</span>.log(hd); <span class="hljs-comment">//[&quot;title&quot;, &quot;木易&quot;, &quot;object&quot;]</span></code></pre><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>压入元素，直接改变元数组，返回值为数组元素数量</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(arr.push(<span class="hljs-string">&quot;向军大叔&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>)); <span class="hljs-comment">//4</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[&quot;木易&quot;, &quot;object&quot;, &quot;向军大叔&quot;, &quot;title&quot;]</span></code></pre><p>根据区间创建新数组</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rangeArray</span>(<span class="hljs-params">begin, end</span>) </span>&#123;  <span class="hljs-keyword">const</span> array = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = begin; i &lt;= end; i++) &#123;    array.push(i);  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-built_in">console</span>.log(rangeArray(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>));</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>从末尾弹出元素，直接改变元数组，返回值为弹出的元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(arr.pop()); <span class="hljs-comment">//object</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[&quot;木易&quot;]</span></code></pre><h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p>从数组前面取出一个元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(arr.shift()); <span class="hljs-comment">//木易</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[&quot;object&quot;]</span></code></pre><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h3><p>从数组前面添加元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(arr.unshift(<span class="hljs-string">&quot;向军大叔&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>)); <span class="hljs-comment">//4</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[&quot;向军大叔&quot;, &quot;title&quot;, &quot;木易&quot;, &quot;object&quot;]</span></code></pre><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>使用<code>fill</code> 填充数组元素</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">Array</span>(<span class="hljs-number">4</span>).fill(<span class="hljs-string">&quot;木易&quot;</span>)); <span class="hljs-comment">//[&quot;木易&quot;, &quot;木易&quot;, &quot;木易&quot;, &quot;木易&quot;]</span></code></pre><p>指定填充位置</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].fill(<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">//[1, &quot;木易&quot;, 3, 4]</span></code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>使用 <code>slice</code> 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [1,2]</span></code></pre><p>不设置参数是为获取所有元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.slice()); <span class="hljs-comment">//[0, 1, 2, 3, 4, 5, 6]</span></code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>使用 <code>splice</code> 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。</p><p>删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.splice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//返回删除的元素 [1, 2, 3]</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//删除数据后的原数组 [0, 4, 5, 6]</span></code></pre><p>通过修改<code>length</code>删除最后一个元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];arr.length = arr.length - <span class="hljs-number">1</span>;<span class="hljs-built_in">console</span>.log(arr);</code></pre><p>通过指定第三个参数来设置在删除位置添加的元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.splice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>)); <span class="hljs-comment">//[1, 2, 3]</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[0, &quot;object&quot;, &quot;木易&quot;, 4, 5, 6]</span></code></pre><p>向末尾添加元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.splice(arr.length, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>)); <span class="hljs-comment">//[]</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, &quot;object&quot;, &quot;木易&quot;]</span></code></pre><p>向数组前添加元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>)); <span class="hljs-comment">//[]</span><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[&quot;object&quot;, &quot;木易&quot;, 0, 1, 2, 3, 4, 5, 6]</span></code></pre><p>数组元素位置调整函数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">array, before, to</span>) </span>&#123;  <span class="hljs-keyword">if</span> (before &lt; <span class="hljs-number">0</span> || to &gt;= array.length) &#123;    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;指定位置错误&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">const</span> newArray = [...array];  <span class="hljs-keyword">const</span> elem = newArray.splice(before, <span class="hljs-number">1</span>);  newArray.splice(to, <span class="hljs-number">0</span>, ...elem);  <span class="hljs-keyword">return</span> newArray;&#125;<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">console</span>.table(move(array, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>));</code></pre><h3 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h3><p>将数组值修改为<code>[]</code>可以清空数组，如果有多个引用时数组在内存中存在被其他变量引用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];<span class="hljs-keyword">let</span> cms = user;user = [];<span class="hljs-built_in">console</span>.log(user);<span class="hljs-built_in">console</span>.log(cms);</code></pre><p>将数组<code>length</code>设置为 0 也可以清空数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];user.length = <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(user);</code></pre><p>使用<code>splice</code>方法删除所有数组元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];user.splice(<span class="hljs-number">0</span>, user.length);<span class="hljs-built_in">console</span>.log(user);</code></pre><p>使用<code>pop/shift</code>删除所有元素，来清空数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;object&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];<span class="hljs-keyword">while</span> (user.pop()) &#123;&#125;<span class="hljs-built_in">console</span>.log(user);</code></pre><h2 id="合并拆分"><a href="#合并拆分" class="headerlink" title="合并拆分"></a>合并拆分</h2><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>使用<code>join</code>连接成字符串</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">&quot;-&quot;</span>)); <span class="hljs-comment">//1-木易-object 使用join可以指定转换的连接方式</span></code></pre><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p><code>split</code> 方法用于将字符串分割成数组，类似<code>join</code>方法的反函数。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price = <span class="hljs-string">&quot;99,78,68&quot;</span>;<span class="hljs-built_in">console</span>.log(price.split(<span class="hljs-string">&quot;,&quot;</span>)); <span class="hljs-comment">//[&quot;99&quot;, &quot;78&quot;, &quot;68&quot;]</span></code></pre><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>concat</code>方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>];<span class="hljs-keyword">let</span> hd = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<span class="hljs-keyword">let</span> cms = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">console</span>.log(array.concat(hd, cms)); <span class="hljs-comment">//[&quot;object&quot;, &quot;title&quot;, 1, 2, 3, 4]</span></code></pre><p>也可以使用扩展语法实现连接</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([...array, ...hd, ...cms]);</code></pre><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h3><p>使用 <code>copyWithin</code> 从数组中复制一部分到同数组中的另外位置。</p><p>语法说明</p><pre><code class="hljs javascript">array.copyWithin(target, start, end);</code></pre><p>参数说明</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>target</em></td><td align="left">必需。复制到指定目标索引位置。</td></tr><tr><td align="left"><em>start</em></td><td align="left">可选。元素复制的起始位置。</td></tr><tr><td align="left"><em>end</em></td><td align="left">可选。停止复制的索引位置 (默认为 <em>array</em>.length)。如果为负值，表示倒数。</td></tr></tbody></table><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">console</span>.log(arr.copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">//[1, 2, 1, 2]</span></code></pre><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>数组包含多种查找的函数，需要把这些函数掌握清楚，然后根据不同场景选择合适的函数。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>使用 <code>indexOf</code> 从前向后查找元素出现的位置，如果找不到返回 <code>-1</code>。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2 从前面查找2出现的位置</span></code></pre><p>如下面代码一下，使用 <code>indexOf</code> 查找字符串将找不到，因为<code>indexOf</code> 类似于<code>===</code>是严格类型约束。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">8</span>)); <span class="hljs-comment">// -1</span></code></pre><p>第二个参数用于指定查找开始位置</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-comment">//从第二个元素开始向后查找</span><span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//4</span></code></pre><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p>使用 <code>lastIndexOf</code> 从后向前查找元素出现的位置，如果找不到返回 <code>-1</code>。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.lastIndexOf(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 4 从后查找2出现的位置</span></code></pre><p>第二个参数用于指定查找开始位置</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-comment">//从第五个元素向前查找</span><span class="hljs-built_in">console</span>.log(arr.lastIndexOf(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//从最后一个字符向前查找</span><span class="hljs-built_in">console</span>.log(arr.lastIndexOf(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>));</code></pre><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>使用 <code>includes</code> 查找字符串返回值是布尔类型更方便判断</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.includes(<span class="hljs-number">8</span>)); <span class="hljs-comment">//true</span></code></pre><p>我们来实现一个自已经的<code>includes</code>函数，来加深对<code>includes</code>方法的了解</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">includes</span>(<span class="hljs-params">array, item</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> array) <span class="hljs-keyword">if</span> (item === value) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-built_in">console</span>.log(includes([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">3</span>)); <span class="hljs-comment">//true</span></code></pre><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find 方法找到后会把值返回出来</p><ul><li>如果找不到返回值为<code>undefined</code></li></ul><p>返回第一次找到的值，不继续查找</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">let</span> find = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">return</span> item == <span class="hljs-string">&quot;object&quot;</span>;&#125;);<span class="hljs-built_in">console</span>.log(find); <span class="hljs-comment">//object</span></code></pre><p>使用<code>includes</code>等不能查找引用类型，因为它们的内存地址是不相等的</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];<span class="hljs-keyword">const</span> find = user.includes(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;);<span class="hljs-built_in">console</span>.log(find);</code></pre><p><code>find</code> 可以方便的查找引用类型</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;木易&quot;</span> &#125;];<span class="hljs-keyword">const</span> find = user.find(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> (user.name = <span class="hljs-string">&quot;木易&quot;</span>));<span class="hljs-built_in">console</span>.log(find);</code></pre><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p><code>findIndex</code> 与 <code>find</code> 的区别是返回索引值，参数也是 : 当前值，索引，操作数组。</p><ul><li>查找不到时返回 <code>-1</code></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(  arr.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;    <span class="hljs-keyword">return</span> v == <span class="hljs-number">8</span>;  &#125;)); <span class="hljs-comment">//3</span></code></pre><h3 id="find-原理"><a href="#find-原理" class="headerlink" title="find 原理"></a>find 原理</h3><p>下面使用自定义函数</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">array, callback</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> array) &#123;    <span class="hljs-keyword">if</span> (callback(value) === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;&#125;<span class="hljs-keyword">let</span> res = find(arr, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">return</span> item == <span class="hljs-number">23</span>;&#125;);<span class="hljs-built_in">console</span>.log(res);</code></pre><p>下面添加原型方法实现</p><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.findValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>) &#123;    <span class="hljs-keyword">if</span> (callback(value) === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;&#125;;<span class="hljs-keyword">let</span> re = arr.findValue(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">return</span> item == <span class="hljs-number">2</span>;&#125;);<span class="hljs-built_in">console</span>.log(re);</code></pre><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转数组顺序</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<span class="hljs-built_in">console</span>.log(arr.reverse()); <span class="hljs-comment">//[9, 2, 4, 1]</span></code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><pre><code class="hljs text">sort`每次使用两个值进行比较 `Array.sort((a,b)=&gt;a-b</code></pre><ul><li>返回负数 a 排在 b 前面，从小到大</li><li>返回正数 b 排在 a 前面</li><li>返回 0 时不动</li></ul><p>默认从小于大排序数组元素</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<span class="hljs-built_in">console</span>.log(arr.sort()); <span class="hljs-comment">//[1, 2, 4, 9]</span></code></pre><p>使用排序函数从大到小排序，参数一与参数二比较，返回正数为降序负数为升序</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<span class="hljs-built_in">console</span>.log(  arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v1, v2</span>) </span>&#123;    <span class="hljs-keyword">return</span> v2 - v1;  &#125;)); <span class="hljs-comment">//[9, 4, 2, 1]</span></code></pre><p>下面是按课程点击数由高到低排序</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">click</span>: <span class="hljs-number">78</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">click</span>: <span class="hljs-number">12</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">click</span>: <span class="hljs-number">99</span> &#125;,];<span class="hljs-keyword">let</span> sortLessons = lessons.sort(<span class="hljs-function">(<span class="hljs-params">v1, v2</span>) =&gt;</span> v2.click - v1.click);<span class="hljs-built_in">console</span>.log(sortLessons);</code></pre><h3 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">array, callback</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">in</span> array) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> m <span class="hljs-keyword">in</span> array) &#123;      <span class="hljs-keyword">if</span> (callback(array[n], array[m]) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">let</span> temp = array[n];        array[n] = array[m];        array[m] = temp;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;arr = sort(arr, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> a - b;&#125;);<span class="hljs-built_in">console</span>.table(arr);</code></pre><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>根据数组长度结合<code>for</code> 循环来遍历数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lessons.length; i++) &#123;  lessons[i] = <span class="hljs-string">`木易: <span class="hljs-subst">$&#123;lessons[i].title&#125;</span>`</span>;&#125;<span class="hljs-built_in">console</span>.log(lessons);</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>使函数作用在每个数组元素上，但是没有返回值。</p><p>下面例子是截取标签的五个字符。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];lessons.forEach(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123;  item.title = item.title.substr(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);&#125;);<span class="hljs-built_in">console</span>.log(lessons);</code></pre><h3 id="for-in"><a href="#for-in" class="headerlink" title="for/in"></a>for/in</h3><p>遍历时的 key 值为数组的索引</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> lessons) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`标题: <span class="hljs-subst">$&#123;lessons[key].title&#125;</span>`</span>);&#125;</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for/of"></a>for/of</h3><p>与 <code>for/in</code> 不同的是 <code>for/of</code> 每次循环取其中的值而不是索引。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> lessons) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`</span><span class="hljs-string">    标题: <span class="hljs-subst">$&#123;item.title&#125;</span></span><span class="hljs-string">    栏目: <span class="hljs-subst">$&#123;item.category == <span class="hljs-string">&quot;css&quot;</span> ? <span class="hljs-string">&quot;前端&quot;</span> : <span class="hljs-string">&quot;数据库&quot;</span>&#125;</span></span><span class="hljs-string">  `</span>);&#125;</code></pre><p>使用数组的迭代对象遍历获取索引与值（有关迭代器知识后面章节会讲到）</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">const</span> iterator = hd.entries();<span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">//value:&#123;0:0,1:&#x27;title&#x27;&#125;</span><span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">//value:&#123;0:1,1:&#x27;object&#x27;&#125;</span></code></pre><p>这样就可以使用解构特性与 <code>for/of</code> 遍历并获取索引与值了</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> hd.entries()) &#123;  <span class="hljs-built_in">console</span>.log(key, value); <span class="hljs-comment">//这样就可以遍历了</span>&#125;</code></pre><p>取数组中的最大值</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayMax</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">let</span> max = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem <span class="hljs-keyword">of</span> array) &#123;    max = max &gt; elem ? max : elem;  &#125;  <span class="hljs-keyword">return</span> max;&#125;<span class="hljs-built_in">console</span>.log(arrayMax([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>]));</code></pre><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><p>数组中可以使用多种迭代器方法，迭代器后面章节会详解。</p><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>通过迭代对象获取索引</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">const</span> keys = hd.keys();<span class="hljs-built_in">console</span>.log(keys.next());<span class="hljs-built_in">console</span>.log(keys.next());</code></pre><p>获取数组所有键</p><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> arr.keys()) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;</code></pre><p>使用 while 遍历</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>];<span class="hljs-keyword">while</span> ((&#123; value, done &#125; = values.keys()) &amp;&amp; done === <span class="hljs-literal">false</span>) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;</code></pre><h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>通过迭代对象获取值</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">const</span> values = hd.values();<span class="hljs-built_in">console</span>.log(values.next());<span class="hljs-built_in">console</span>.log(values.next());<span class="hljs-built_in">console</span>.log(values.next());</code></pre><p>获取数组的所有值</p><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr.values()) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;</code></pre><h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><p>返回数组所有键值对，下面使用解构语法循环</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> arr.entries()) &#123;  <span class="hljs-built_in">console</span>.log(key, value);&#125;</code></pre><p>解构获取内容（对象章节会详细讲解）</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hd = [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;object&quot;</span>];<span class="hljs-keyword">const</span> iterator = hd.entries();<span class="hljs-keyword">let</span> &#123;  done,  value: [k, v],&#125; = iterator.next();<span class="hljs-built_in">console</span>.log(v);</code></pre><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p><code>every</code> 用于递归的检测元素，要所有元素操作都要返回真结果才为真。</p><p>查看班级中同学的 JS 成绩是否都及格</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">js</span>: <span class="hljs-number">89</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;马六&quot;</span>, <span class="hljs-attr">js</span>: <span class="hljs-number">55</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">js</span>: <span class="hljs-number">78</span> &#125;,];<span class="hljs-keyword">const</span> resust = user.every(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.js &gt;= <span class="hljs-number">60</span>);<span class="hljs-built_in">console</span>.log(resust);</code></pre><p>标题的关键词检查</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> words = [<span class="hljs-string">&quot;夜勃&quot;</span>, <span class="hljs-string">&quot;分享&quot;</span>, <span class="hljs-string">&quot;知识&quot;</span>];<span class="hljs-keyword">let</span> title = <span class="hljs-string">&quot;木易不断分享技术教程&quot;</span>;<span class="hljs-keyword">let</span> state = words.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, array</span>) </span>&#123;  <span class="hljs-keyword">return</span> title.indexOf(item) &gt;= <span class="hljs-number">0</span>;&#125;);<span class="hljs-keyword">if</span> (state == <span class="hljs-literal">false</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;标题必须包含所有关键词&quot;</span>);</code></pre><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>使用 <code>some</code> 函数可以递归的检测元素，如果有一个返回 true，表达式结果就是真。第一个参数为元素，第二个参数为索引，第三个参数为原数组。</p><p>下面是使用 <code>some</code> 检测规则关键词的示例，如果匹配到一个词就提示违规。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> words = [<span class="hljs-string">&quot;木易&quot;</span>, <span class="hljs-string">&quot;分享&quot;</span>, <span class="hljs-string">&quot;知识&quot;</span>];<span class="hljs-keyword">let</span> title = <span class="hljs-string">&quot;木易不断分享技术教程&quot;</span>;<span class="hljs-keyword">let</span> state = words.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, array</span>) </span>&#123;  <span class="hljs-keyword">return</span> title.indexOf(item) &gt;= <span class="hljs-number">0</span>;&#125;);<span class="hljs-keyword">if</span> (state) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;标题含有违规关键词&quot;</span>);</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>使用 <code>filter</code> 可以过滤数据中元素，下面是获取所有在 CSS 栏目的课程。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];<span class="hljs-keyword">let</span> cssLessons = lessons.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, array</span>) </span>&#123;  <span class="hljs-keyword">if</span> (item.category.toLowerCase() == <span class="hljs-string">&quot;css&quot;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;&#125;);<span class="hljs-built_in">console</span>.log(cssLessons);</code></pre><p>我们来写一个过滤元素的方法来加深些技术</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">except</span>(<span class="hljs-params">array, excepts</span>) </span>&#123;  <span class="hljs-keyword">const</span> newArray = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem <span class="hljs-keyword">of</span> array) <span class="hljs-keyword">if</span> (!excepts.includes(elem)) newArray.push(elem);  <span class="hljs-keyword">return</span> newArray;&#125;<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">console</span>.log(except(array, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">//[1,4]</span></code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>使用 <code>map</code> 映射可以在数组的所有元素上应用函数，用于映射出新的值。</p><p>获取数组所有标题组合的新数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];<span class="hljs-built_in">console</span>.log(lessons.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.title));</code></pre><p>为所有标题添加上 <code>木易</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lessons = [  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;媒体查询响应式布局&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;FLEX 弹性盒模型&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;css&quot;</span> &#125;,  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;MYSQL多表查询随意操作&quot;</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;mysql&quot;</span> &#125;,];lessons = lessons.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, array</span>) </span>&#123;  item.title = <span class="hljs-string">`[木易] <span class="hljs-subst">$&#123;item[<span class="hljs-string">&quot;title&quot;</span>]&#125;</span>`</span>;  <span class="hljs-keyword">return</span> item;&#125;);<span class="hljs-built_in">console</span>.log(lessons);</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>使用 <code>reduce</code> 与 <code>reduceRight</code> 函数可以迭代数组的所有元素，<code>reduce</code> 从前开始 <code>reduceRight</code> 从后面开始。下面通过函数计算课程点击数的和。</p><p>第一个参数是执行函数，第二个参数为初始值</p><ul><li>传入第二个参数时将所有元素循环一遍</li><li>不传第二个参数时从第二个元素开始循环</li></ul><p>函数参数说明如下</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>prev</td><td>上次调用回调函数返回的结果</td></tr><tr><td>cur</td><td>当前的元素值</td></tr><tr><td>index</td><td>当前的索引</td></tr><tr><td>array</td><td>原数组</td></tr></tbody></table><p>统计元素出现的次数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countArrayELem</span>(<span class="hljs-params">array, elem</span>) </span>&#123;  <span class="hljs-keyword">return</span> array.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> (total += cur == elem ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];<span class="hljs-built_in">console</span>.log(countArrayELem(numbers, <span class="hljs-number">1</span>)); <span class="hljs-comment">//2</span></code></pre><p>取数组中的最大值</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayMax</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">return</span> array.reduce(<span class="hljs-function">(<span class="hljs-params">max, elem</span>) =&gt;</span> (max &gt; elem ? max : elem), array[<span class="hljs-number">0</span>]);&#125;<span class="hljs-built_in">console</span>.log(arrayMax([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>]));</code></pre><p>取价格最高的商品</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> cart = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;iphone&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">12000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;imac&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">25000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ipad&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">3600</span> &#125;,];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxPrice</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">return</span> array.reduce(    (goods, elem) =&gt; (goods.price &gt; elem.price ? goods : elem),    array[<span class="hljs-number">0</span>]  );&#125;<span class="hljs-built_in">console</span>.log(maxPrice(cart));</code></pre><p>计算购物车中的商品总价</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> cart = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;iphone&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">12000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;imac&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">25000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ipad&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">3600</span> &#125;,];<span class="hljs-keyword">const</span> total = cart.reduce(<span class="hljs-function">(<span class="hljs-params">total, goods</span>) =&gt;</span> (total += goods.price), <span class="hljs-number">0</span>);<span class="hljs-built_in">console</span>.log(total); <span class="hljs-comment">//40600</span></code></pre><p>获取价格超过 1 万的商品名称</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> goods = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;iphone&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">12000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;imac&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">25000</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ipad&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">3600</span> &#125;,];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNameByPrice</span>(<span class="hljs-params">array, price</span>) </span>&#123;  <span class="hljs-keyword">return</span> array    .reduce(<span class="hljs-function">(<span class="hljs-params">goods, elem</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (elem.price &gt; price) &#123;        goods.push(elem);      &#125;      <span class="hljs-keyword">return</span> goods;    &#125;, [])    .map(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> elem.name);&#125;<span class="hljs-built_in">console</span>.table(getNameByPrice(goods, <span class="hljs-number">10000</span>));</code></pre><p>使用 <code>reduce</code> 实现数组去重</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">let</span> filterArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur, index, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (pre.includes(cur) === <span class="hljs-literal">false</span>) &#123;    pre = [...pre, cur];  &#125;  <span class="hljs-keyword">return</span> pre;&#125;, []);<span class="hljs-built_in">console</span>.log(filterArr); <span class="hljs-comment">// [1,2,6]</span></code></pre><h2 id="动画案例"><a href="#动画案例" class="headerlink" title="动画案例"></a>动画案例</h2><p><img src="https://s1.ax1x.com/2020/08/17/dmM6SJ.gif" alt="Untitled"></p><blockquote><p>css</p></blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#2c3e50</span>;&#125;* &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#9b59b6</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">5em</span>;  <span class="hljs-attribute">font-weight</span>: bold;  <span class="hljs-attribute">text-transform</span>: uppercase;  <span class="hljs-attribute">cursor</span>: pointer;&#125;<span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">span</span> &#123;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">display</span>: inline-block;&#125;<span class="hljs-selector-class">.changeColor</span> &#123;  <span class="hljs-attribute">animation-name</span>: changeColor;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">1s</span>;  <span class="hljs-attribute">animation-direction</span>: alternate;  <span class="hljs-attribute">animation-iteration-count</span>: <span class="hljs-number">2</span>;  <span class="hljs-attribute">animation-timing-function</span>: linear;&#125;<span class="hljs-keyword">@keyframes</span> changeColor &#123;  50% &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#f1c40f</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);  &#125;  <span class="hljs-selector-tag">to</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#9b59b6</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);  &#125;&#125;</code></pre><blockquote><p>html</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>zxq.acs.pw<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>JavaScript</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div&quot;</span>);[...div.textContent].reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;  pre == index &amp;&amp; (div.innerHTML = <span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-keyword">let</span> span = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;span&quot;</span>);  span.textContent = cur;  div.appendChild(span);  span.addEventListener(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.classList.add(<span class="hljs-string">&quot;changeColor&quot;</span>);  &#125;);  span.addEventListener(<span class="hljs-string">&quot;animationend&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.classList.remove(<span class="hljs-string">&quot;changeColor&quot;</span>);  &#125;);&#125;, <span class="hljs-number">0</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
