<!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/FD.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="记录学习的点点滴滴"><meta name="author" content="不愿透露姓名的周先生"><meta name="keywords" content="前端,JavaScript,技术,个人博客,学习,笔记,周新桥,前端程序员,技术博客,废物,kkfive, "><title>NodeJs 文件操作 - 看看废物的博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/pojoaque.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"www.kkfive.com",root:"/",version:"1.8.5",typing:{enable:!0,typeSpeed:70,cursorChar:"🛸",loop:!1},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},copy_btn:!0,image_zoom:{enable:!0},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!0,baidu:"7c3a86d2ad975111fcb1544184425260",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>废物的主页</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 文章</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(https://darrenclover.gitee.io/img/guidang.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="NodeJs 文件操作"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-09-27 19:04" pubdate>September 27, 2020 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.8k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">NodeJs 文件操作</h1><div class="markdown-body"><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><p><code>HTTP</code>模块的作用是创建一个服务器，<code>HTTP</code>是Node的内置模块，不用在单独下载</p><p>使用<code>requier</code>指令来导入http模块，将实例化的<code>HTTP</code>赋值给<code>http</code></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);</code></pre></div><p>使用<code>http</code>模块的<code>createServer()</code> 方法创建服务器，使用<code>listen</code> 方法绑定端口号，<code>listen</code>方法接收两个个参数，第一个参数要绑定的端口号，第二个参数服务启动成功后执行的回调函数<code>createServer(</code>)方法有两个参数,<code>request</code>, <code>response</code>分别表示接收数据和响应数据，基本结构如以下代码</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;
  response.end(<span class="hljs-string">&quot;hello&quot;</span>);
&#125;);

server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);
&#125;);
</code></pre></div><p><code>response.end(&quot;hello&quot;)</code>向页面响应数据，访问<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000/</a> 就可以看到响应的数据</p><p><img src="https://files.alexhchu.com/2020/09/25/2c3039caffbd1.png" srcset="/img/loading.gif" alt="image-20200925200231905"></p><p>如果响应的数据为中文，则会出现乱码</p><p><img src="https://files.alexhchu.com/2020/09/25/465da338c39e2.png" srcset="/img/loading.gif" alt="image-20200925202709457"></p><p>出现乱码的原因是头部编码，在响应前设置编码头信息就可以解决</p><div class="hljs"><pre><code class="hljs javascript">response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);</code></pre></div><h2 id="FS模块"><a href="#FS模块" class="headerlink" title="FS模块"></a>FS模块</h2><p><code>FS</code>模块的作用是用来读写文件，对文件进行交互的模块</p><p>通过<code>required</code>来引入模块</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);</code></pre></div><p><code>FS</code>模块中有两种才操作形式：同步和异步</p><ul><li>同步：会阻塞程序的进行，等文件全部读取完毕才会向下执行代码</li><li>异步：不会阻塞程序的进行，在读取文件的时候，可以进行其他的操作</li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><strong>同步操作</strong></p><p><code>fs.readFileSync</code>方法是同步来读取文件，首先创建一个txt文件，随便写点内容</p><p><img src="https://files.alexhchu.com/2020/09/25/50a0b6c1f8cbd.png" srcset="/img/loading.gif" alt="image-20200925201404951"></p><p>然后通过<code>fs.readFileSync</code>来读取文件，并响应到页面中</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">let</span> res = fs.readFileSync(<span class="hljs-string">&quot;./1.txt&quot;</span>);
  response.end(res);
&#125;);

server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);
&#125;);</code></pre></div><p>访问<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000/</a> 就可以看到文件中的内容</p><p><img src="https://files.alexhchu.com/2020/09/25/1e4df5f74353d.png" srcset="/img/loading.gif" alt="image-20200925201655775"></p><p><strong>异步操作</strong></p><p><code>fs.readFile()</code>方法是来异步读取文件，异步和同步读取方法的区别就是是否带有<code>Sync</code>关键字，凡是加了<code>Sync</code>的方法同步操作，否则就是异步操作</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">let</span> res = fs.readFile(<span class="hljs-string">&quot;./1.txt&quot;</span>);
  response.end(res);
&#125;);

server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);
&#125;);</code></pre></div><p>访问<a target="_blank" rel="noopener" href="http://localhost:3000/%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9C%8B%E5%88%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">http://localhost:3000/可以正常看到读取文件中的内容</a></p><p><img src="https://files.alexhchu.com/2020/09/25/1e4df5f74353d.png" srcset="/img/loading.gif" alt="image-20200925201655775"></p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><code>fs.writeFileSync()</code>方法：接收四个参数 <code>fs.writeFile(file, data[, options], callback)</code></p><ul><li>file - 文件名或文件描述符</li><li>data - 要写入文件的数据</li><li>options - 该参数是一个对象,用来表明写入的行为<ul><li>r+ ： 读取文件</li><li>w+ ： 打开文件用于读写，会覆盖目标文件的原内容，如果文件不存在则创建文件</li><li>a ：追加写入，如果文件不存在则创建文件。</li></ul></li><li>callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;
  response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);
  fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;Hello world&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;w&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (err) &#123;
      <span class="hljs-built_in">console</span>.log(err);
    &#125;
  &#125;);
  response.end(<span class="hljs-string">&quot;你好&quot;</span>);
&#125;);

server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);
&#125;);</code></pre></div><p>向2.txt文件中写入内容hello world，如果2.txt没有，那么系统会自动帮我们创建</p><p>打开2.txt就可以看到我们刚才写入的内容</p><p><img src="https://files.alexhchu.com/2020/09/25/fa515160f3897.png" srcset="/img/loading.gif" alt="image-20200925213612961"></p><p>如果我们更改一下写入的内容，重新运行代码，会发现之前写入的内容消失了，而显示的是新写入的内容</p><div class="hljs"><pre><code class="hljs javascript">fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;木易&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;w&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (err) &#123;
      <span class="hljs-built_in">console</span>.log(err);
    &#125;
  &#125;);</code></pre></div><p><img src="https://files.alexhchu.com/2020/09/25/990be9b74c767.png" srcset="/img/loading.gif" alt="image-20200925214449339"></p><p>这是因为我们使用的写入行为是<code>w</code>，会覆盖文件中的内容，将写入行为改为<code>a</code>就可以追加写入了</p><div class="hljs"><pre><code class="hljs javascript">fs.writeFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;博客&quot;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&quot;a&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (err) &#123;
      <span class="hljs-built_in">console</span>.log(err);
    &#125;
  &#125;);</code></pre></div><p><img src="https://files.alexhchu.com/2020/09/25/dbee4a29bb43f.png" srcset="/img/loading.gif" alt="image-20200925214621462"></p><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><p>使用 <code>fs.rename()</code> 或 <code>fs.renameSync()</code> 可以重命名文件。 第一个参数要被修改的文件名，第二个参数是新的文件名</p><p>现在将2.txt重命名为3.txt，代码如下</p><div class="hljs"><pre><code class="hljs javascript">fs.rename(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-built_in">console</span>.log(err);
  &#125;
&#125;);</code></pre></div><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>fs.unlink()</code>方法可以删除指定的文件，该方法接收两个参数，第一个参数表示要删除的文件名，第二个参数为报错时运行的回调函数</p><p>现在将3.txt进行删除，代码如下</p><div class="hljs"><pre><code class="hljs javascript">fs.unlink(<span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(err);
  &#125;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除成功&quot;</span>);
&#125;);</code></pre></div><h3 id="流方式读取文件"><a href="#流方式读取文件" class="headerlink" title="流方式读取文件"></a>流方式读取文件</h3><p><code>fs.readFileSync</code>方法和<code>fs.writeFileSync()</code>方法适合拷贝一些小文件，但是如果想一次性把所有文件读取到内存再一次性写入到文件中这两种方法就不适合，对于大文件，我们只能读一点写一点，流方式非常适合大文件的读取</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;
  response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);
  fs.createReadStream(<span class="hljs-string">&quot;./1.txt&quot;</span>).pipe(fs.createWriteStream(<span class="hljs-string">&quot;./3.txt&quot;</span>));
  response.end(<span class="hljs-string">&quot;hello&quot;</span>);
&#125;);

server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器启动成功 请访问 http://localhost:3000/&quot;</span>);
&#125;);</code></pre></div><p>以上代码使用<code>fs.createReadStream()</code>方法创建第一个源文件只读数据流，使用<code>fs.createWriteStream()</code>方法创建了一个目标文件的只写数据流，使用<code>pipe</code>方法把两个数据流连接起来，整个读写过程如下图</p><p><img src="https://files.alexhchu.com/2020/09/27/b2ca4cab3eec1.png" srcset="/img/loading.gif" alt="image-20200927110116025"></p><h2 id="PATH模块"><a href="#PATH模块" class="headerlink" title="PATH模块"></a>PATH模块</h2><p><code>PATH</code>模块的主要功能是用来处理路径的工具，可以简化路径的相关操作</p><ul><li><p><code>path.normalize</code></p><p>将传入的路径转换为标准路径，除了可以解析路径中的<code>.</code>和<code>..</code>外，还可以去除多余的斜杠</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> cache = &#123;&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">store</span>(<span class="hljs-params">key, value</span>) </span>&#123;
    cache[path.normalize(key)] = value;
&#125;

store(<span class="hljs-string">&#x27;foo/bar&#x27;</span>, <span class="hljs-number">1</span>);
store(<span class="hljs-string">&#x27;foo//baz//../bar&#x27;</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(cache);  <span class="hljs-comment">//  &#123; &quot;foo/bar&quot;: 2 &#125;</span></code></pre></div></li></ul><ul><li><p><code>path.extname</code></p><p>可以获取文件的后缀名，当我们需要根据不同文件的后缀名做不同操作时，可以使用该方法</p><div class="hljs"><pre><code class="hljs javascript">path.extname(<span class="hljs-string">&#x27;server.js&#x27;</span>); <span class="hljs-comment">// =&gt; &quot;.js&quot;</span></code></pre></div></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><ul><li><code>Buffer</code>是用来处理二进制数据的缓存区</li><li>除了读取文件获取<code>Buffer</code>以外，还可以直接构造</li><li><code>Buffer</code>将 JS 的数据处理能力从字符串扩展到了任意二进制数据</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bin = <span class="hljs-keyword">new</span> Buffer([ <span class="hljs-number">0x68</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6f</span> ]);</code></pre></div><p><code>Buffer</code>与字符串类似，可以用<code>length</code>属性获得字节长度，也可以使用<code>[]</code>方式去读指定位置的字节</p><div class="hljs"><pre><code class="hljs javascript">bin[<span class="hljs-number">0</span>]; <span class="hljs-comment">//  0x68;</span></code></pre></div><p><code>Buffer</code>与字符串可以相互转化，可以将指定的二进制数据转换为字符串</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = bin.toString(<span class="hljs-string">&#x27;utf-8&#x27;</span>); <span class="hljs-comment">// =&gt; &quot;hello&quot;</span></code></pre></div><h2 id="Stream-数据流"><a href="#Stream-数据流" class="headerlink" title="Stream (数据流)"></a>Stream (数据流)</h2><p>当内存中无法一次性存储需要处理的数据，可以改为一边读取一边处理的方法，这就需要用到数据流，NodeJs中可以使用 <code>Stream</code>来对数据流进行操作</p><p>所有的<code>Stream</code>对象都是<code>EventEmitter</code> 的实例。常用的事件有：</p><ul><li><code>data</code>：当有数据可读取时触发</li><li><code>end</code>：没有更多的数据可读取时触发</li><li><code>error</code>：在接收和写入过程中发生错误时触发</li><li><code>finish</code>：所有数据已被写入到底层系统时触发</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rs = fs.createReadStream(pathname);

rs.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;
    doSomething(chunk);
&#125;);

rs.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    cleanUp();
&#125;);</code></pre></div><p>上述代码中<code>data</code>事件会一直触发，不管<code>doSomething</code>函数是否能处理过来,<code>createReadStream()</code>中有两个方法可以解决此问题</p><ul><li><code>rs.pause()</code> 暂停读取,会暂停data事件的触发，将流动模式转变非流动模式</li><li><code>rs.resume()</code>恢复data事件,继续读取，变为流动模式</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rs = fs.createReadStream(src);

rs.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;
    rs.pause();
    doSomething(chunk, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        rs.resume();
    &#125;);
&#125;);

rs.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    cleanUp();
&#125;);</code></pre></div><p>上述代码给<code>doSomething</code>函数添加了一个回调函数，在处理数据前暂停数据读取，在处理后继续读取数据</p><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p><h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div><p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p><blockquote><p><strong>陷阱：</strong> 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</p></blockquote><h3 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h3><p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。</p><div class="hljs"><pre><code class="hljs latex">    A
   / <span class="hljs-tag">\</span>
  B   C
 / <span class="hljs-tag">\<span class="hljs-name"> </span></span>  <span class="hljs-tag">\</span>
D   E   F</code></pre></div><h3 id="同步遍历"><a href="#同步遍历" class="headerlink" title="同步遍历"></a>同步遍历</h3><p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travel</span>(<span class="hljs-params">dir, callback</span>) </span>&#123;
    fs.readdirSync(dir).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>&#123;
        <span class="hljs-keyword">var</span> pathname = path.join(dir, file);

        <span class="hljs-keyword">if</span> (fs.statSync(pathname).isDirectory()) &#123;
            travel(pathname, callback);
        &#125; <span class="hljs-keyword">else</span> &#123;
            callback(pathname);
        &#125;
    &#125;);
&#125;</code></pre></div><p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p><div class="hljs"><pre><code class="hljs text">- /home/user/
    - foo/
        x.js
    - bar/
        y.js
    z.css</code></pre></div><p>使用以下代码遍历该目录时，得到的输入如下。</p><div class="hljs"><pre><code class="hljs javascript">travel(<span class="hljs-string">&#x27;/home/user&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pathname</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(pathname);
&#125;);

------------------------
/home/user/foo/x.js
/home/user/bar/y.js
/home/user/z.css</code></pre></div><h3 id="异步遍历"><a href="#异步遍历" class="headerlink" title="异步遍历"></a>异步遍历</h3><p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travel</span>(<span class="hljs-params">dir, callback, finish</span>) </span>&#123;
    fs.readdir(dir, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, files</span>) </span>&#123;
        (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">i</span>) </span>&#123;
            <span class="hljs-keyword">if</span> (i &lt; files.length) &#123;
                <span class="hljs-keyword">var</span> pathname = path.join(dir, files[i]);

                fs.stat(pathname, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) </span>&#123;
                    <span class="hljs-keyword">if</span> (stats.isDirectory()) &#123;
                        travel(pathname, callback, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                            next(i + <span class="hljs-number">1</span>);
                        &#125;);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        callback(pathname, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                            next(i + <span class="hljs-number">1</span>);
                        &#125;);
                    &#125;
                &#125;);
            &#125; <span class="hljs-keyword">else</span> &#123;
                finish &amp;&amp; finish();
            &#125;
        &#125;(<span class="hljs-number">0</span>));
    &#125;);
&#125;</code></pre></div></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a> <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF/NodeJS/">NodeJS</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/NodeJs/">NodeJs</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/posts/496507a6/index.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Koa2框架学习基本语法和使用</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"> <a href="/posts/15/index.html"><span class="hidden-mobile">图解HTTP第五章：与 HTTP 协作的 Web 服务器</span> <span class="visible-mobile">Next</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>页脚</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:200}),NProgress.start(),document.addEventListener("DOMContentLoaded",function(){window.NProgress&&window.NProgress.inc()}),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js"></script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js"></script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7c3a86d2ad975111fcb1544184425260";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>